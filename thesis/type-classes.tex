\section{Type Classes}
In this section we informally describe type classes and their semantics. The
following example defines a type class for testing the equality of values
called \texttt{Eq}:
%
\begin{verbatim}
    class Eq a where
      (==) :: a -> a -> Bool
\end{verbatim}
%
As we mentioned earlier, type classes allow for ad-hoc polymorphism and the method
specified in the class declaration body can be used with any type that
implements the required methods of the type class by providing an instance.
This differs from parametric polymorphism in the way that the \texttt{(==)}
operator cannot be applied to any type \texttt{a}, but only the types that provide an
instance for the type class. The signature is therefore not entirely honest and
has a implied type class constraint:
\begin{verbatim}
    (==) :: Eq a => a -> a -> Bool
\end{verbatim}
Types that contain type class constraints like the one above are called
\textit{qualified types}~\cite{JonesThesis} and could possibly appear in the type signatures of
functions where these polymorphic methods are used.
% TODO example of usage?

To use these polymorphic methods we provide an instance declaration for every type
we wish to use them on. The following is an example of a type class instance
declaration for the \texttt{Bool} datatype:
%  type which contains an implementation of the
% methods for which a type signature was specified in the corresponding class
% declaration.
% GEORGE: Getting too abstract makes it difficult to read. Keep it simple
\begin{verbatim}
    instance Eq Bool where
      True  == True  = True
      False == False = True
      _     == _     = False
\end{verbatim}
%
A instance declaration for polymorphic types (types with type parameters) might
require certain instance declarations for these parametrized types. In order to avoid unnecessarily restricting such instances,
we can specify required class constraints in the {\em instance context} of an instance declaration:
\begin{verbatim}
    instance Eq a => Eq [a] where
      []     == []     = True
      (a:as) == (b:bs) = a == b && as == bs
      _      == _      = False
\end{verbatim}
It is required that the equality is also defined for the element type to
implement the equality for lists. Hence, the implication \texttt{Eq a => Eq [a]}
tells us that if we have a instance of \texttt{Eq} for a type \texttt{a}, we
automatically have an instance for a list of \texttt{a}s too.

The next example is a class declaration of the \texttt{Ord} type class, which
represents ordering. The implication in the declaration specifies a hierarchy
between type classes. This means that providing an instance declaration for the
\textbf{superclass}, in this case \texttt{Eq}, is a prerequisite for being
able to define an instance declaration for \texttt{Ord}.

Note that the implication should be interpreted in the inverse direction and
actually means: if we have a instance for \texttt{Ord} we also have one for
\texttt{Eq}.
\begin{verbatim}
    class Eq a => Ord a where
      (<=) :: a -> a -> Bool
\end{verbatim}
%
Type classes could be extended to not just support one type parameter but
multiple parameters and we can define functional dependencies between these
types. These concepts will be described in the next section.
