\section{Type Classes}
In this section we'll describe type classes and their semantics. In the
following example we defined a type class for testing the equality of values
called \texttt{Eq}.

\begin{verbatim}
    class Eq a where
      (==) :: a -> a -> Bool
\end{verbatim}

As mentioned before, type classes allow for ad-hoc polymorphism and the method
specified in the class declaration body can be used with any type that
implements the required methods of the type class by providing an instance.
This differs from parametric polymorphism in the way that the \texttt{==}
operator cannot be applied to any \texttt{a}. But only the types that provide an
instance for the type class. The signature is therefore not entirely honest and
has a implied type class constraint.
\begin{verbatim}
    (==) :: Eq a => a -> a -> Bool
\end{verbatim}
Type signatures that contain these type class constraints are called
\textit{qualified types} and could possibly appear in the type signatures of the
functions where these polymophic methods are used.
% TODO example of usage?

To use these polymophic methods we provide instance declaration for every type
we wish to use them on. The following is an example of an type class instance
delcaration for the \texttt{Bool} type which contains an implementation of the
methods for which a type signature was specified in the corresponding class
declaration.
\begin{verbatim}
    instance Eq Bool where
      True  == True  = True
      False == False = True
      _     == _     = False
\end{verbatim}

A instance declaration for polymorphic types (types with type parameters) might
require certain instance delcarations for these parametriced types. Because
these types are not known we can specify these type classes as an imlication in
the instance delcaration.
\begin{verbatim}
    instance Eq a => Eq [a] where
      []     == []     = True
      (a:as) == (b:bs) = b == b && as == bs
      _      == _      = False
\end{verbatim}
To implement the equality for lists, it is required that the equality is also
defined for it's element type. Hence the implication \texttt{Eq a => Eq[a]}
which tells us that if we have a instance of Eq for a type \texttt{a}, we
automatically also have an instance for the list of \texttt{a}'s

The next example is a class declaration of the \texttt{Ord} type class which
represents ordering. The implication in the declaration specifies a hierarchy
between type classes. Which means that the \textbf{superclass}, in this case
\texttt{Eq} instance should be provided for the type as a prerequisite for being
able to provide one for \texttt{Ord}

Note that the implication should be interpreted in the inverse direction and
actually means: if we have a instance for \texttt{Ord} we alse have one for
\texttt{Eq}.
\begin{verbatim}
    class Eq a => Ord a where
      (<=) :: a -> a -> Bool
\end{verbatim}

Type classes could be extended to not just support one type parameter but
multiple parameters and we can define functional dependencies between these
types. These concepts will be described in the next section.
