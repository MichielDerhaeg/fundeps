\chapter{Conditions}
\label{cha:conditions}

Up until now we have only mentioned how to do type inference in the presence of
functional dependencies. But functional dependencies are in essence a
restriction imposed on instance declarations, a restriction we have yet to
specify how to enforce. And as mentioned in the previous
chapter~\ref{cha:entailment}, certain restrictions have to be put in place on
class and instance declarations to make sure type checking terminates.
In this chapter we will discuss how to enforce these and other desirable
properties usually found in Haskell implementations.

\section{Termination}

\subsection{Directed acyclic graph}
Before we type check class declarations, we have to verify that the superclass
relations forms a directed acyclic graph. This is to ensure termination of the
determinacy relation discussed in section~\ref{sec:determinacy} and the
computation of match context discussed in section~\ref{sec:match-contexts}.

Both of these procedures compute the transitive closure of the superclass
relation and if this relation would be represented by a cyclic graph, these
functions would never terminate. We therefore simply enforce this is not the
case when type checking class declarations.
\begin{figure}
\fbox{$cycleCheck(\overline{TC}, TC) = \bullet_\bot$}
\begin{mathpar}
\inferrule*[right=Cyclic]
{
    TC \in \overline{TC}
}
{
    cycleCheck(\overline{TC}; TC) = \bot
}
\\
\inferrule*[right=Acyclic]
{
    TC \notin \overline{TC}
    \\
    class \; \forall{a}. \; \overline{TC' \; \overline{u}'}^m \Rightarrow TC \;
    \overline{u}
}
{
    cycleCheck(\overline{TC}; TC) = \overline{cycleCheck(\overline{TC}, TC;
    TC_i')}^m
}
\end{mathpar}
\end{figure}

\subsection{Instance declarations}
To ensure termination for class constraint entailment, in particular the
$topreact_w$ rule for class constraints, we employ the termination condition of
the the Paterson Conditions \cite{fundeps-chrs},~Def.~11. So given an instance
declaration $instance \; \forall \overline{a}. \; \overline{\pi} \Rightarrow TC
\; \overline{u}$:

\begin{itemize}
    \item Every type variable of $\overline{a}$ has no more occurrences in a
    single type class constraint $\pi$ the context $\overline{\pi}$ than in the
    head $TC \; \overline{u}$.

    \item The total number of type constructors and variables in the context
    $\overline{\pi}$, including repititions, should be less than the number in
    $\overline{u}$.
\end{itemize}

%TODO weren't we going to replace this one?
Secondly, to ensure termination for for constraint entailment with regards to
type families, we impose very similar restrictions on every equality axiom
generated by instance declarations. These conditions are inspired by the class
termination conditions and borrowed from Schrijvers et
al.~\cite{type-checking-with-open-type-functions} .
For every axiom $g \; \overline{a} : F(\overline{u}) \sim \tau$, for every
$F'(\overline{\tau}') \subseteq \tau$:
\begin{itemize}
    \item $\overline{\tau}'$ contains no type family applications

    \item Every type variariable of $\overline{a}$ has no more occurences in
    $\overline{\tau}'$ than in $\overline{u}$.

    \item The total number of type constructors and type variables in
    $\overline{\tau}'$, including repitions, should be less than the number in
    $\overline{u}$.
\end{itemize}

\section{Functional Dependency Property}

To enforce the functional dependency property we impose two conditions. The
\textit{Compatibility Condition} (Def 6.2
\cite{Karachalias:2017:EFD:3156695.3122966}) and \textit{Unambiguous Witness
Functions} (Def 6.4 \cite{Karachalias:2017:EFD:3156695.3122966}).

\subsection{Compatibility}

\begin{figure}
%TODO unify can be \bot too, how do we specify this?
\fbox{$P \vdash_{compat} S_I$}
\begin{mathpar}
\inferrule*[right=Compat]
{
  \overline{\forall \overline{a}_2 \overline{b}_2. \; \overline{\pi}_2 \Rightarrow
  TC \; \overline{u}_2} \in P
  \\
  \text{class} \; \forall \overline{a} \overline{b}. \; \overline{\pi}
  \Rightarrow TC \; \overline{a} \mid \overline{fd}
  \\
  fd_i \equiv a_{i_1}, \mathellipsis, a_{i_n} \rightarrow a_{i_0}
  \\
  \theta_{i1} = det(fv(\overline{u}_1^{i_n}), \overline{\pi}_1)
  \\
  \theta_{i2} = det(fv(\overline{u}_2^{i_n}), \overline{\pi}_2)
  \\
  \theta_\bot = unify(\bullet; \overline{u_1^i \sim u_2^i}^n)
  \\
  \theta(\theta_{i1}(u_{i_01})) = \theta(\theta_{i1}(u_{i_02}))
}
{
  P \vdash_{compat} \forall \overline{a}_1 \overline{b}_1. \; \overline{\pi}_1 \Rightarrow TC \;
  \overline{u}_1
}
\end{mathpar}
\caption{Compatibility Condition}
\label{fig:compat}
\end{figure}

For every instance declaration we verify whether or not they are
\textit{compatible} with all other previously defined instance declarations. The
implementation of the definition of compatibility condition by Karachalias et
al.~\cite{Karachalias:2017:EFD:3156695.3122966} is specified in
figure~\ref{fig:compat}.

This condition serves the same purpose as \textit{Consistency} (Def. 8
\cite{fundeps-chrs}), originally defined by Jones~\cite{Jones00typeclasses}.
It verifies for every functional dependency if the domain indeed determines the
range for every pair of instance declarations. In other words, if for two
instance declarations the domain of a functional dependency overlaps, the type
of the range should be the same.  Note that if the unification of the domain
fails, the condition is trivially satisfied. It prevents situations like the
following example from being accepted by the type checker.
%TODO better example? contrived example that is more liberal maybe?
\begin{verbatim}
    class C a b | a -> b
    instance C Int Int
    instance C Int Bool
\end{verbatim}

Unlike the formalization of consistency, it uses the determinacy relation to see
if the image of the dependency can be fully determined by also taking the
instance context into account. Making this condition more liberal than the
consistency condition.

\subsection{Unambiguous Witness}

This condition verifies that the determinacy relation $det(\overline{a},
\overline{\pi})$, discussed in section~\ref{sec:determinacy}, is deterministic
and produces the same substitution regardless o

\begin{figure}
%TODO substitute question mark
\fbox{$P \vdash_{?} S_I$}
\begin{mathpar}
\inferrule*[right=UnambWitness]
{
  \text{class} \; \forall \overline{a} \overline{b}. \; \overline{\pi}
  \Rightarrow TC \; \overline{a} \mid \overline{fd}
  \\
  fd_i \equiv a_{i_1}, \mathellipsis, a_{i_n} \rightarrow a_{i_0}
  \\
  \theta = det(fv(\overline{u}^{i_n}), \overline{\pi}')
  \\
  \overline{\beta} = fv(u_{i_0})
  \\
  \overline{\beta} \subseteq dom(\theta)
  \\
  [\beta_i \mapsto \tau_1] \in \theta
  \\
  [\beta_i \mapsto \tau_2] \in \theta
  \\
  \tau_1 = \tau_2
}
{
  P \vdash_{?} \forall \overline{a}' \overline{b}'. \; \overline{\pi}' \Rightarrow TC \;
  \overline{u}
}
\end{mathpar}
\caption{Unambiguous Witness Functions}
\label{fig:unamb-witness}
\end{figure}

\subsection{Coverage}

\section{Ambiguity}

\section{Coherence}
