\chapter{Conditions}
\label{cha:conditions}

Up until now we have only mentioned how to do type inference in the presence of
functional dependencies. But functional dependencies are in essence a
restriction imposed on instance declarations, a restriction we have yet to
specify how to enforce. As mentioned in the previous
chapter~\ref{cha:entailment}, certain restrictions have to be put in place on
class and instance declarations to make sure type checking terminates.
In this chapter we discuss how to enforce these and other desirable
properties usually enforced in Haskell implementations.

\section{Termination}
\label{sec:termination}

\subsection{Directed acyclic graph}
Before we type check class declarations, we have to verify that the superclass
relation forms a directed acyclic graph. This is to ensure termination of the
determinacy relation discussed in section~\ref{sec:determinacy} and the
computation of match contexts discussed in section~\ref{sec:match-contexts}.

Both of these procedures compute the transitive closure of the superclass
relation and if this relation would be represented by a cyclic graph, these
functions would never terminate. We therefore simply enforce this is not the
case when type checking class declarations.
\begin{figure}
\begin{mathpar}
\inferrule*[right=Acyclic]
{
    TC \notin \overline{TC}
    \\
    class \; \forall{a}. \; \overline{TC' \; \overline{u}'}^m \Rightarrow TC \;
    \overline{u}
    \\ 
    \overline{acyclic(\overline{TC}, TC; TC_i')}^m
}
{
    acyclic(\overline{TC}; TC)
}
\end{mathpar}
\end{figure}

\subsection{Instance declarations}
To ensure termination for class constraint entailment, in particular the
$topreact_w$ rule for class constraints, we employ the termination condition of
the the Paterson Conditions \cite[Def.~11]{fundeps-chrs}. So given an instance
declaration $instance \; \forall \overline{a}. \; \overline{\pi} \Rightarrow TC
\; \overline{u}$:

\begin{itemize}
    \item Every type variable of $\overline{a}$ has no more occurrences in a
    single type class constraint $\pi$ the context $\overline{\pi}$ than in the
    head $TC \; \overline{u}$.

    \item For every constraint $\pi$ in the context $\overline{\pi}$, the total
    number of type constructors and variables , including repititions, should be
    less than the number in $\overline{u}$.
\end{itemize}
%TODO examples from GHC user guide are nice

%TODO weren't we going to replace this one?
Secondly, to ensure termination for for constraint entailment with regards to
type families, we impose very similar restrictions on every equality axiom
generated by instance declarations. These conditions are inspired by the class
termination conditions and borrowed from Schrijvers et
al.~\cite{type-checking-with-open-type-functions} .
For every axiom $g \; \overline{a} : F(\overline{u}) \sim \tau$, for every
$F'(\overline{\tau}') \subseteq \tau$:
\begin{itemize}
    \item $\overline{\tau}'$ contains no type family applications

    \item Every type variariable of $\overline{a}$ has no more occurences in
    $\overline{\tau}'$ than in $\overline{u}$.

    \item The total number of type constructors and type variables in
    $\overline{\tau}'$, including repitions, should be less than the number in
    $\overline{u}$.
\end{itemize}

\section{Functional Dependency Property}

To enforce the functional dependency property we impose two conditions. The
\textit{Compatibility
Condition}~\cite[Def.~6.2]{Karachalias:2017:EFD:3156695.3122966}) and
\textit{Unambiguous Witness Functions}~\cite[Def
6.4]{Karachalias:2017:EFD:3156695.3122966}.

\subsection{Compatibility}

\begin{figure}
%TODO unify can be \bot too, how do we specify this?
\fbox{$P \vdash_{compat} S_I$}
\begin{mathpar}
\inferrule*[right=Compat]
{
  \overline{\forall \overline{a}_2 \overline{b}_2. \; \overline{\pi}_2 \Rightarrow
  TC \; \overline{u}_2} \in P
  \\
  \text{class} \; \forall \overline{a} \overline{b}. \; \overline{\pi}
  \Rightarrow TC \; \overline{a} \mid \overline{fd}
  \\
  fd_i \equiv a_{i_1}, \mathellipsis, a_{i_n} \rightarrow a_{i_0}
  \\
  \theta_{i1} = det(fv(\overline{u}_1^{i_n}), \overline{\pi}_1)
  \\
  \theta_{i2} = det(fv(\overline{u}_2^{i_n}), \overline{\pi}_2)
  \\
  \theta_\bot = unify(\bullet; \overline{u_1^i \sim u_2^i}^n)
  \\
  \theta(\theta_{i1}(u_{i_01})) = \theta(\theta_{i1}(u_{i_02}))
}
{
  P \vdash_{compat} \forall \overline{a}_1 \overline{b}_1. \; \overline{\pi}_1 \Rightarrow TC \;
  \overline{u}_1
}
\end{mathpar}
\caption{Compatibility Condition}
\label{fig:compat}
\end{figure}

For every instance declaration we verify whether or not they are
\textit{compatible} with all other previously defined instance declarations. The
implementation of the definition of compatibility condition by Karachalias et
al.~\cite{Karachalias:2017:EFD:3156695.3122966} is specified in
figure~\ref{fig:compat}.

This condition serves the same purpose as \textit{Consistency}~\cite[Def.~8]{fundeps-chrs}, originally defined by Jones~\cite{Jones00typeclasses}.
It verifies for every functional dependency if the domain indeed determines the
range for every pair of instance declarations. In other words, if for two
instance declarations the domain of a functional dependency overlaps, the type
of the range should be the same.  Note that if the unification of the domain
fails, the condition is trivially satisfied. It prevents situations like the
following example from being accepted by the type checker.
%TODO better example? contrived example that is more liberal maybe?
\begin{verbatim}
    class C a b | a -> b
    instance C Int Int
    instance C Int Bool
\end{verbatim}

Unlike the formalization of consistency, it uses the determinacy relation to see
if the image of the dependency can be fully determined by also taking the
instance context into account, making this condition more liberal than the
consistency condition.

\subsection{Unambiguous Witness}

\begin{figure}
\fbox{$P \vdash_{W} S_I$}
\begin{mathpar}
\inferrule*[right=UnambWitness]
{
  \text{class} \; \forall \overline{a} \overline{b}. \; \overline{\pi}
  \Rightarrow TC \; \overline{a} \mid \overline{fd}
  \\
  fd_i \equiv a_{i_1}, \mathellipsis, a_{i_n} \rightarrow a_{i_0}
  \\
  \theta = det(fv(\overline{u}^{i_n}), \overline{\pi}')
  \\
  \overline{\beta} = fv(u_{i_0})
  \\
  \overline{\beta} \subseteq dom(\theta)
  \\
  [\beta_i \mapsto \tau_1] \in \theta
  \\
  [\beta_i \mapsto \tau_2] \in \theta
  \\
  \tau_1 = \tau_2
}
{
  P \vdash_{W} \forall \overline{a}' \overline{b}'. \; \overline{\pi}' \Rightarrow TC \;
  \overline{u}
}
\end{mathpar}
\caption{Unambiguous Witness Functions}
\label{fig:unamb-witness}
\end{figure}

\[
\begin{array}{l l l l}
\text{class} \; &\forall \overline{a} \overline{b}. \; \overline{\pi}
&\Rightarrow TC \; \overline{a} \mid \overline{fd}^m &\text{where} \; f ::
\sigma
\\
\text{instance} \; &\forall \overline{a}' \overline{b}'. \; \overline{\pi}'
&\Rightarrow TC \; \overline{a}' &\text{where} \; f = e
\end{array}
\]

Karachalias and Schrijvers define this condition as follows: ``For each functional
dependency $fd_i \equiv \overline{a}^{i_n} \rightarrow a_{i_0}$ it is required
that $det(fv(\overline{u}^{i_n}),\overline{\pi}') $ is non-ambiguous on
$fv(u_{i_0})$''~\cite[Def.~6.4]{Karachalias:2017:EFD:3156695.3122966}.
This means that regardless the order in which the determinacy relation derives the
witness derivation(i.e. the substitution) from $\overline{\pi}'$, the resulting
substitution should be equivalent when applied to $fv(u_{i_0})$.

The implementation of this check abuses the implementation of the determinacy
relation. Depending on the order the determinacy procedure specified in
figure~\ref{fig:determinacy} selects the next class constraint, the order in
which the substitution is constructed is different. If the resulting
substitution is ambiguous it would contain two pairs $[\beta \mapsto \tau_1]$
and $[\beta \mapsto \tau_2]$ that would map the same type variable to two
syntactically distinct types. This check verifies the absence of such two pairs.

%TODO example?

\subsection{Coverage}
\label{sec:coverage}

%TODO cite chrs second sentence?
The last functional dependency related condition we will discuss is coverage.
It verifies that determining the types in the domain fully determines the type
in the range. We employ the \textit{Liberal Coverage Condition}~\cite[Def.~15]{fundeps-chrs}, which is verified during axiom generation specified in
figure~\ref{fig:axiomgen} and not as an external check. It is implicitly
verified by checking if the free variables of the image of every generated axiom are
a subset of the free variables of the domain. It is easy to see that this is
equivalent to the liberal coverage condition and the transitive closure
is simply computed earlier by the determinacy relation.

%TODO we could easily verify this externally like the axiom termination
%check

%TODO example

\section{Ambiguity}

Ambiguity occurs when there is a class constraint over a type variable where the
type variable can never be determined.

\begin{verbatim}
    show :: Show a => a -> String
    read :: Read a => String -> a
    f x = show (read x)
\end{verbatim}

% damnit latex layout
% TODO nicely explained in introduction, what do i explain here? do i repeat
% myself?
% TODO really unsatisfied with this
In this classic example of ambiguity the type of \texttt{f} would
be:\footnote{The type would be \texttt{String -> String} in GHCi, and therefore
not ambiguous, because \texttt{a} would default to \texttt{()}.}
\begin{verbatim}
    (Show a, Read a) => String -> String
\end{verbatim}
No matter the context in which \texttt{f} is used, the type of \texttt{a} can
never be determined and is therefore ambiguous.

In these simple examples, checking for ambiguity would simply consist of
checking if all of the type variables in the context would also appear in what
they happen to be quantifying over which would imply they can be directly
determined. But this procedure becomes a bit more involved when functional
dependencies are present. Either these variables are present or can be
determined indirectly by another type through a functional dependency or even a
chain of several. For example:
\begin{verbatim}
    class C a b | a -> b
    f :: C a b => a -> a
\end{verbatim}

Even though \texttt{b} does not appear in the monotype component of the
signature of \texttt{f}, \texttt{a} does and \texttt{b} can be determined
through \texttt{a} using the functional dependency making the type signature of
\texttt{f} unambiguous.

\subsection{Ambiguous class/instance contexts}

\[
\begin{array}{l l l}
\text{class} \; &\forall \overline{a} \overline{b}. \; \overline{\pi}
&\Rightarrow TC \; \overline{u}
\\
\text{instance} \; &\forall \overline{a} \overline{b}. \; \overline{\pi}
&\Rightarrow TC \; \overline{u}
\end{array}
\]
\[
unambContext(\overline{b},\overline{a},\overline{\pi}) = \overline{b} \subseteq
dom(det(\overline{a},\overline{\pi}))
\]

For class and instance contexts we have to verify that the type variables
$\overline{b}$ that do not appear in the head $TC \; \overline{u}$ but only in
the context $\overline{\pi}$ can be completely determined by $\overline{a}$.
This is quite straightforward using the determinacy relation. If the determinacy
relation creates a substitution for every variable in $\overline{b}$ we know
that they can all be determined and the context is unambiguous.

\subsection{Ambiguous types}

Checking for ambiguity for types, inferred or annotated, is also rather
straightforward but unlike with class/instance contexts we have to take type
families into account. We don't allow type families in the source text but this
restriction does not hold for inferred types.

\[
\begin{array}{l l l l}
fixed(a) &= {a} &\quad fixed(\tau_1 \; \tau_2) & = fixed(\tau_1) \cup
fixed(\tau_2) \\
fixed(T) &= \bullet &\quad fixed(F(\overline{\tau})) &= \bullet \\
\end{array}
\]
\begin{mathpar}
\inferrule*
{
    \sigma \equiv \forall \overline{a}. \; \overline{\pi} \Rightarrow \tau
    \\
    fv(\overline{\pi}) \subseteq dom(det(fixed(\tau),\overline{\pi})) \cup
    fixed(\tau)
}
{
    unambType(\sigma)
}
\end{mathpar}

The check is very similar to the class/instance case but instead we only
consider the \textit{fixed} type variables of the monotype $\tau$ to be directly
determined. The \textit{fixed} type variables are the variables that do not
solely occur within type family applications. Consider the following example:

\begin{verbatim}
    C a b | a -> b
    h :: C a b => F a

    f :: Int
    f = h
\end{verbatim}

Given that $F(Int) \sim Int$ and $F(Bool) \sim Int$, the usage of \texttt{h} in
the body of \texttt{f} gives rise to the wanted constraint $F(a) \sim Int$.  $a$
could in this case be $Int$ or $Bool$. And therefore the usage of \texttt{h}
does not determine the type of $a$ and indirectly the type of $b$.  Even worse,
this makes $a$ itself ambiguous and this should be rejected regardless of the
given class constraint $C \; a \; b$.
%TODO are the free variables of the class cs sufficient? does it need to include
%the free vars of sigma too? maybe not, they have to occur as part of type class
%constraints

\newpage
\section{Coherence}

This is the last property that needs an explicit check to be ensured and was
briefly discussed section~\ref{sec:binary-interaction}. Coherence ensures that
no matter how a type class constraint is resolved and the corresponding
evidence is derived, the operational semantics of the resulting program should
always be the same. The semantics of type classes are defined in the methods of
instance declarations and therefore for any given types the choice for an
instance should always be the same. This implies it suffices to restrict
instance declarations to be \textit{non-overlapping}. No instantiation of a type
class constraint can possibly match with the heads of two different instance
declarations.
%TODO simple example?

This property is again verified for every instance declaration. We attempt to
unify the head of every instance declaration with the corresponding head of
every other previously defined instance declaration. If unification produces a
valid substitution, then there exists an instantiation of the
constraint that can match both instance declarations and the program should be
rejected. If no such substitution exists, unification fails and all is well.
\begin{figure}
\begin{mathpar}
\inferrule*
{
    (\forall \overline{a}. \; \overline{\pi} \Rightarrow TC \; \overline{u}')
    \in P
    \\
    \bot = unify(\bullet,\overline{u_i \sim u_i'})
}
{
    overlapCheck(P,TC \; \overline{u})
}
\end{mathpar}
\end{figure}
