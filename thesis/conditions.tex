\chapter{Conditions}
\label{cha:conditions}

Up until now we have only mentioned how to do type inference in the presence of
functional dependencies. But functional dependencies are in essence a
restriction imposed on instance declarations, a restriction we have yet to
specify how to enforce. And as mentioned in the previous
chapter~\ref{cha:entailment}, certain restrictions have to be put in place on
class and instance declarations to make sure type checking terminates.
In this chapter we will discuss how to enforce these and other desirable
properties usually found in Haskell implementations.

\section{Termination}

\subsection{Directed acyclic graph}
Before we type check class declarations, we have to verify that the superclass
relations forms a directed acyclic graph. This is to ensure termination of the
determinacy relation discussed in section~\ref{sec:determinacy} and the
computation of match context discussed in section~\ref{sec:match-contexts}.

Both of these procedures compute the transitive closure of the superclass
relation and if this relation would be represented by a cyclic graph, these
functions would never terminate. We therefore simply enforce this is not the
case when type checking class declarations.
\begin{figure}
\fbox{$cycleCheck(\overline{TC}, TC) = \bullet_\bot$}
\begin{mathpar}
\inferrule*[right=Cyclic]
{
    TC \in \overline{TC}
}
{
    cycleCheck(\overline{TC}; TC) = \bot
}
\\
\inferrule*[right=Acyclic]
{
    TC \notin \overline{TC}
    \\
    class \; \forall{a}. \; \overline{TC' \; \overline{u}'}^m \Rightarrow TC \;
    \overline{u}
}
{
    cycleCheck(\overline{TC}; TC) = \overline{cycleCheck(\overline{TC}, TC;
    TC_i')}^m
}
\end{mathpar}
\end{figure}

\subsection{Instance declarations}
To ensure termination for class constraint entailment, in particular the
$topreact_w$ rule for class constraints, we employ the termination condition of
the the Paterson Conditions \cite{fundeps-chrs},~Def.~11. So given an instance
declaration $instance \; \forall \overline{a}. \; \overline{\pi} \Rightarrow TC
\; \overline{u}$:

\begin{itemize}
    \item Every type variable of $\overline{a}$ has no more occurrences in a
    single type class constraint $\pi$ the context $\overline{\pi}$ than in the
    head $TC \; \overline{u}$.

    \item For every constraint $\pi$ in the context $\overline{\pi}$, the total
    number of type constructors and variables , including repititions, should be
    less than the number in $\overline{u}$.
\end{itemize}
%TODO examples from GHC user guide are nice

%TODO weren't we going to replace this one?
Secondly, to ensure termination for for constraint entailment with regards to
type families, we impose very similar restrictions on every equality axiom
generated by instance declarations. These conditions are inspired by the class
termination conditions and borrowed from Schrijvers et
al.~\cite{type-checking-with-open-type-functions} .
For every axiom $g \; \overline{a} : F(\overline{u}) \sim \tau$, for every
$F'(\overline{\tau}') \subseteq \tau$:
\begin{itemize}
    \item $\overline{\tau}'$ contains no type family applications

    \item Every type variariable of $\overline{a}$ has no more occurences in
    $\overline{\tau}'$ than in $\overline{u}$.

    \item The total number of type constructors and type variables in
    $\overline{\tau}'$, including repitions, should be less than the number in
    $\overline{u}$.
\end{itemize}

\section{Functional Dependency Property}

To enforce the functional dependency property we impose two conditions. The
\textit{Compatibility Condition} (Def 6.2
\cite{Karachalias:2017:EFD:3156695.3122966}) and \textit{Unambiguous Witness
Functions} (Def 6.4 \cite{Karachalias:2017:EFD:3156695.3122966}).

\subsection{Compatibility}

\begin{figure}
%TODO unify can be \bot too, how do we specify this?
\fbox{$P \vdash_{compat} S_I$}
\begin{mathpar}
\inferrule*[right=Compat]
{
  \overline{\forall \overline{a}_2 \overline{b}_2. \; \overline{\pi}_2 \Rightarrow
  TC \; \overline{u}_2} \in P
  \\
  \text{class} \; \forall \overline{a} \overline{b}. \; \overline{\pi}
  \Rightarrow TC \; \overline{a} \mid \overline{fd}
  \\
  fd_i \equiv a_{i_1}, \mathellipsis, a_{i_n} \rightarrow a_{i_0}
  \\
  \theta_{i1} = det(fv(\overline{u}_1^{i_n}), \overline{\pi}_1)
  \\
  \theta_{i2} = det(fv(\overline{u}_2^{i_n}), \overline{\pi}_2)
  \\
  \theta_\bot = unify(\bullet; \overline{u_1^i \sim u_2^i}^n)
  \\
  \theta(\theta_{i1}(u_{i_01})) = \theta(\theta_{i1}(u_{i_02}))
}
{
  P \vdash_{compat} \forall \overline{a}_1 \overline{b}_1. \; \overline{\pi}_1 \Rightarrow TC \;
  \overline{u}_1
}
\end{mathpar}
\caption{Compatibility Condition}
\label{fig:compat}
\end{figure}

For every instance declaration we verify whether or not they are
\textit{compatible} with all other previously defined instance declarations. The
implementation of the definition of compatibility condition by Karachalias et
al.~\cite{Karachalias:2017:EFD:3156695.3122966} is specified in
figure~\ref{fig:compat}.

This condition serves the same purpose as \textit{Consistency} (Def. 8
\cite{fundeps-chrs}), originally defined by Jones~\cite{Jones00typeclasses}.
It verifies for every functional dependency if the domain indeed determines the
range for every pair of instance declarations. In other words, if for two
instance declarations the domain of a functional dependency overlaps, the type
of the range should be the same.  Note that if the unification of the domain
fails, the condition is trivially satisfied. It prevents situations like the
following example from being accepted by the type checker.
%TODO better example? contrived example that is more liberal maybe?
\begin{verbatim}
    class C a b | a -> b
    instance C Int Int
    instance C Int Bool
\end{verbatim}

Unlike the formalization of consistency, it uses the determinacy relation to see
if the image of the dependency can be fully determined by also taking the
instance context into account. Making this condition more liberal than the
consistency condition.

\subsection{Unambiguous Witness}

\begin{figure}
\fbox{$P \vdash_{W} S_I$}
\begin{mathpar}
\inferrule*[right=UnambWitness]
{
  \text{class} \; \forall \overline{a} \overline{b}. \; \overline{\pi}
  \Rightarrow TC \; \overline{a} \mid \overline{fd}
  \\
  fd_i \equiv a_{i_1}, \mathellipsis, a_{i_n} \rightarrow a_{i_0}
  \\
  \theta = det(fv(\overline{u}^{i_n}), \overline{\pi}')
  \\
  \overline{\beta} = fv(u_{i_0})
  \\
  \overline{\beta} \subseteq dom(\theta)
  \\
  [\beta_i \mapsto \tau_1] \in \theta
  \\
  [\beta_i \mapsto \tau_2] \in \theta
  \\
  \tau_1 = \tau_2
}
{
  P \vdash_{W} \forall \overline{a}' \overline{b}'. \; \overline{\pi}' \Rightarrow TC \;
  \overline{u}
}
\end{mathpar}
\caption{Unambiguous Witness Functions}
\label{fig:unamb-witness}
\end{figure}

\[
\begin{array}{l l l l}
\text{class} \; &\forall \overline{a} \overline{b}. \; \overline{\pi}
&\Rightarrow TC \; \overline{a} \mid \overline{fd}^m &\text{where} \; f ::
\sigma
\\
\text{instance} \; &\forall \overline{a}' \overline{b}'. \; \overline{\pi}'
&\Rightarrow TC \; \overline{a}' &\text{where} \; f = e
\end{array}
\]

Karachalias et al. defined this condition as follows: "For each functional
dependency $fd_i \equiv \overline{a}^{i_n} \rightarrow a_{i_0}$ it is required
that $det(fv(\overline{u}^{i_n}),\overline{\pi}') $ is non-amiguous on
$fv(u_{i_0})$"\cite{Karachalias:2017:EFD:3156695.3122966} (Def 6.4)
Meaning that in regardless which order the determinacy relation derives the
witness derivation(i.e. the substitution) from $\overline{\pi}'$, the resulting
substitution should be equivalent when applied to $fv(u_{i_0})$.

The implementation of this check abuses the implementation of the determinacy
relation. Depending on the order the determinacy procedure specified in
figure~\ref{fig:determinacy} selects the next class constraint, the order in
which the substitution is constructed is different. If the resulting
substitution is ambiguous it would contain two pairs $[\beta \mapsto \tau_1]$
and $[\beta \mapsto \tau_2]$ that would map the same type variable to two
syntactically distinct types. This check verifies the absence of such two pairs.

\subsection{Coverage}

%TODO cite chrs second sentence?
The last functional dependency related condition we will discuss is coverage.
It verifies that determining the types in the domain fully determines the type
in the range. We employ the \textit{Liberal Coverage Condition}(Def.
15\cite{fundeps-chrs}), which is verified during axiom generation specified in
figure~\ref{fig:axiomgen} and not as an external check. It is implicitly
verified by checking if the free variables of image of every generated axiom are
a subset of the free variables of the domain. It is easy to see that this is
equivalent as the liberal coverage condition and instead the transitive closure
is computed early by the determinacy relation

%TODO we could easily verify this like externally like the axiom termination
%check

\section{Ambiguity}

\subsection{Ambiguous class contexts}

\subsection{Ambiguous types}

\section{Coherence}
