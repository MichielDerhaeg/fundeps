\chapter{Inference and Elaboration}
\label{cha:inference}
Like most systems similar to Hindley-Milner, type inference occurs in two
distinct phases. The first involves constraint generation, and the second
involves solving those constraints. The latter will be discussed in
chapter~\ref{cha:entailment} about constraint entailment.

During constraint generation the Haskell code is simultaneously elaborated into
System $F_C$. However, even though System $F_C$ is an explicitly typed language,
the types it should be annotated with are not yet known. Therefore every
expression will be assigned a "placeholder" unification type variable that might
be substituted with the actual type after the constraints have been solved.

A similar approach is used for type classes. As mentioned previously, type
classes are elaborated into System $F_C$ as dictionary terms that hold the class
methods. Because these are also not yet known, placeholder dictionary variables
are used instead.

\section{Source Syntax}
\begin{figure}
\begin{align*}
    a, b &::= \; \langle type \; variable \rangle \\
    x, f &::= \; \langle term \; variable \rangle \\
    T    &::= \; \langle type \; constructor \rangle \\
    K    &::= \; \langle data \; constructor \rangle \\
    TC   &::= \; \langle class \; constructor \rangle \\
    F    &::= \; \langle type \; family \rangle \\
    \\
    pgm &::= \overline{decl} &program\\
    decl &::= cls \mid inst \mid data \mid val &declaration\\
    cls &::= \textbf{class} \; \forall \overline{a} \overline{b}. \;
    \overline{\pi} \Rightarrow TC \; \overline{a} \mid \overline{fd}^m
    \textbf{where} \; f :: \sigma &class\\
    inst &::= \textbf{instance} \; \forall \overline{a} \overline{b}. \;
    \overline{\pi} \Rightarrow TC \; \overline{u} \; \textbf{where} \; f = e
    &instance\\
    data &::= \textbf{data} \; T \; \overline{a} = \overline{K \; \overline{a}
    \;} &data\\
    val &::= x = e \mid x :: \sigma = e &value \; binding\\
    fd &::= a_1, \mathellipsis, a_n \rightarrow a_0 &fundep\\
    \\
    e &::= x \mid K \mid e_1 \; e_2 \mid \lambda x. \; e \mid \textbf{let} \; x
    = e_2 \; \textbf{in} \; e_2 \\
    &\quad \mid \textbf{case} \; e_{scr} \; \textbf{of} \; \overline{K \; \overline{x}
    \rightarrow e} &term \\
    \\
    \sigma &::= \rho \mid \forall a. \; \sigma &polytype \\
    \rho &::= \tau \mid \pi \Rightarrow \rho &qualified \; type \\
    \tau &::= a \mid T \mid \tau_1 \; \tau_2 \mid F(\overline{\tau})
         &monotype \\
    u &::= a \mid T \mid u_1 \; u_2 &type \; pattern \\
    \\
    \pi &::= TC \; \overline{\tau} &class \; constraint \\
    \\
\end{align*}
%TODO put scheme and equality constraint with inference syntax?
\caption{Source syntax}
\label{fig:source-syntax}
\end{figure}
The syntax of our Haskell-like source programs is given in
figure~\ref{fig:source-syntax}. It is highly similar to Haskell '98 except for
several additions and simplifications. Type classes can have
multiple type parameters instead of one. In class and instance declarations we
differentiate between $\overline{a}$, the type variables that occur in the type
class parameters, and $\overline{b}$, the type variables that solely occur in the
context $\overline{\pi}$. Reason being that this doesn't have to be an issue if
these $\overline{b}$ can be uniquely determined by functional dependencies.

Class declarations can now be annotated with functional dependencies of the form
$a_1, \mathellipsis, a_n \rightarrow a_0$, where $a_1, \mathellipsis, a_n$ is
commonly referred to the \textit{domain} and $a_0$ as the \textit{range} of the
functional dependency. GHC allows for functional dependencies of the form $a
\rightarrow b \; c$ with multiple types to the right of the arrow. These are
called \textit{multi-range} functional dependencies, but these can be translated
into the \textit{single-range} variant \cite{fundeps-chrs} and are therefore not
considered in this work.
%TODO multi-range is strictly stronger when coverage condition is violated, we
%use liberal coverage condition, so this is not always true?

Expressions are a simple $\lambda$-calculus extended with ADT data constructors,
case expressions and let expressions.

%TODO more about type families?
Monotypes have been extended with type family applications $F(\overline{\tau})$
\cite{associated-types-with-class} similar to System $F_C$. These are not
allowed in the source text and are only used internally. Therefore, we also
define type patterns denoted by $u$. These are simple monotypes that do not
contain any type families. On top of that we have qualified types and polytypes.
Even though GHC allows types to be qualified with equality constraints in
addition to type class constraints, we only allow class constraints for
simplicity. Note that there is no mention of arrow types, these are considered
type constructors. The type $a \rightarrow b$ would in practice look like
$((\rightarrow) \; a) \; b$ with $(\rightarrow)$ a primitive for the arrow type
constructor.

\begin{figure}
\begin{align*}
    P &::= \langle \mathcal{S}, \mathcal{A}, \mathcal{C}_g \rangle &program \;
    theory
    \\
    \\
    \mathcal{C}_w &::= \bullet \mid \mathcal{C}_w, d : \pi \mid \mathcal{C}_w, c
    : \phi &wanted \; constraints
    \\
    \mathcal{P}_w &::= \bullet \mid \mathcal{P}_w, d : \pi &wanted \; class \;
    constraints
    \\
    \mathcal{E}_w &::= \bullet \mid \mathcal{E}_w, c : \phi &wanted \; equality
    \; constraints
    \\
    \\
    \mathcal{C}_g &::= \bullet \mid \mathcal{C}_g, t : \pi \mid \mathcal{C}_g,
    \gamma: \phi &given \; constraints
    \\
    \\
    \mathcal{A} &::= \bullet \mid \mathcal{A}, g \; \overline{a} :
    F(\overline{u}) \sim \tau &equality \; axioms
    \\
    \mathcal{S} &::= \bullet \mid \mathcal{S}, d : S &annotated \; constraint \;
    schemes
    \\ 
    \\
    \phi &::= \tau_1 \sim \tau_2 &equality \; constraint
    \\
    S &::= \forall \overline{a}. \overline{\pi} \Rightarrow \pi &constraint \;
    scheme
    \\
    \\
    \eta &::= \bullet \mid [d \mapsto t] \cdot \eta \mid [c \mapsto \gamma]
    \cdot \eta &evidence \; substitution
    \\
    \theta &::= \bullet \mid [\alpha \mapsto \tau] \cdot \theta &type \;
    substitution
    \\
    \Gamma &::= \bullet \mid \Gamma, x : \sigma \mid \Gamma, a : k &typing \; environment
    \\
    \\
    d &::= \langle dictionary \; variable \rangle
\end{align*}
\caption{Inference syntax}
\label{fig:inference-syntax}
\end{figure}
\subsection{Inference Syntax}
%TODO maybe put tyfam extended monotypes here?
%TODO tyfam info should be put somewhere too
Figure~\ref{fig:inference-syntax} describes additional syntax used by the type
checker during inference.

Constraint schemes $S$ capture implications generated by instance declarations
and unlike many formalizations not by class declarations. Equality constraints
denoted by $\phi$ are of the form $\tau_1 \sim \tau_2$ which simply means that
type $\tau_1$ should be equal to $\tau_2$. As we will see in
section~\ref{sec:fundeps}, functional dependencies give rise to equality axioms,
denoted by $\mathcal{A}$. These are simply the Haskell counterpart of System
$F_C$ top-level equality axioms and are semantically equivalent, note that $g$
is an $F_C$ axiom variable in either case. Class and equality constraints can be
annotated with dictionary variables and coercion variables respectively.

The program theory, denoted by $P$ is a triple of annotated constraint schemes
equality axioms and a set of local given constraints.


The typing environment is standard and stores types of term variables and type
variables with their kinds.

\input{infer-fundeps}

\section{Constraint Generation}
\begin{figure}[h]
% TmVar
% TODO fix and define P and E
% TODO include \notin dom
$$
\inferrule*[right=TmVar]
{
    (x : \forall \overline{a} \overline{b}. \overline{\pi} \Rightarrow \tau) \in
    \Gamma
    \\
    \overline{\alpha},\overline{d} \; \text{fresh}
    \\
    \theta = [ \overline{\alpha} \mapsto \overline{a}] \; \cdot \; det(\overline{\pi},
    \overline{a})
}
{
    \Gamma \vdash_{tm} x : \theta(\tau) \rightsquigarrow x \; \overline{\alpha}
    \; \theta(\overline{b}) \; \overline{d} \; | \; \overline{d : \theta(\pi)}; \bullet
}
$$
% TmAbs
$$
\inferrule*[right=TmAbs]
{
    \Gamma, x : \alpha \vdash_{tm} e : \tau \rightsquigarrow t \; | \; P ; E
    \\
    \alpha \; \text{fresh}
}
{
    \Gamma \vdash_{tm} \lambda x. e : ( \alpha \rightarrow \tau) \rightsquigarrow
    \lambda (x : \alpha) . t \; | \; P ; E
}
$$
% TmApp
$$
\inferrule*[right=TmApp]
{
    \Gamma \vdash_{tm} e_1 : \tau_1 \; | \; P_1; E_1
    \\
    \Gamma \vdash_{tm} e_2 : \tau_2 \; | \; P_2; E_2
    \\
    \alpha, c \; \text{fresh}
    \\
    P = P_1, P_2
    \\
    E = E_1, E_2, c : \tau_1 \sim (\tau_1 \rightarrow \alpha)
}
{
    \Gamma \vdash_{tm} e_1 \; e_2 : a \rightsquigarrow (t_1 \triangleright c) \; t_2
    \; | \; P ; E
}
$$
% TmLet
$$
\inferrule*[right=TmLet]
{
    \Gamma, x : \alpha \vdash_{tm} e_1: \tau_1 \rightsquigarrow t_1 \; | \;
    P_1; E_1
    \\
    \Gamma, x : \alpha \vdash_{tm} e_2: \tau_2 \rightsquigarrow t_2 \; | \;
    P_2; E_2
    \\
    \alpha, c \; \text{fresh}
    \\
    P = P_1, P_2
    \\
    E = E_1, E_2, c : \alpha \sim \tau_1
}
{
    \Gamma \vdash_{tm} (\textbf{let} \; x = e_1 \; \textbf{in} \; e_2) : \tau_2
    \rightsquigarrow (\textbf{let} \; x : \tau_1 = t_1 \; \textbf{in} \; t_2) \;
    | \; P ; E
}
$$
% TmCon
$$
\inferrule*[right=TmCon]
{
    (K : \forall \overline{a} . \tau) \in \Gamma
    \\
    \overline{\beta} \; \text{fresh}
}
{
    \Gamma \vdash_{tm} K : [ \overline{\alpha \mapsto \beta}] \tau
    \rightsquigarrow K \; \overline{\beta} \; | \; \bullet ; \bullet
}
$$
% TmCase
$$
\inferrule*[right=TmCase]
{
    \Gamma \vdash_{tm} e_{scr} : \tau_{scr} \rightsquigarrow t_{scr} \mid P_{scr}; E_{scr}
    \\
    \alpha, \overline{\beta}, c, \overline{c'} \; \text{fresh}
    \\
    (K_i : \forall \overline{a}. \overline{\tau}^i \rightarrow T \; \overline{a})
    \in \Gamma
    \\
    \Gamma, \overline{x_i : [\overline{a \mapsto \beta}]\tau_{e_i}} \vdash_{tm} e_i
    : \tau_{e_i} \rightsquigarrow t_{e_i} \mid P_{e_i}; E_{e_i}
}
{
    \Gamma \vdash_{tm} \textbf{case} \; e_{scr} \; \textbf{of} \; \overline{K \;
    \overline{x} \rightarrow e} : \alpha \rightsquigarrow \textbf{case} \;
    t_{scr} \triangleright c \; \textbf{of} \; \overline{K \; \overline{x} \rightarrow t
    \triangleright c'} \\
    \mid P_{scr}, \overline{P_e}; E_{scr}, \overline{E_e}, c : \tau_{scr} \sim T
    \; \overline{\beta}, \overline{c' : \tau_e \sim \alpha}
}
$$
\caption{Term Elaboration and Constraint Generation}
\end{figure}

\section{Match Contexts}
\label{sec:match-contexts}
% TODO rename dictDestruction? no longer defined in terms of dictionary brings
% TODO mention that we can't use superclass projections for coercions
% everything context related in scope
% Explain type class dictionaries

This procedure deals with bringing relevant structures in scope related
to type class contexts. It brings super classes in scope and type equalities
introduced by functional dependencies.
\begin{verbatim}
class Eq a => Ord a
sort :: Ord a => [a] -> [a]
\end{verbatim}
In this example, \texttt{Eq} is a superclass of \texttt{Ord}. Because having
implemented an instance for \texttt{Eq} is a prerequisite for \texttt{Ord}, we
should read the implication arrow in the class declaration in the other
direction. If we know that there is an instance for \texttt{Ord}, then we can
assume there is one for \texttt{Eq} as well. We could add the \texttt{Ord a =>
Eq a} implication to the program theory as is. But this implication would
always overlap with those from the instance declarations which would make
solving type class constraints non-deterministic.

The solution is to preemptively, additionally add the instantiated super class
constraints from the context as given class constraints. And we do the same with
the superclasses of the superclasses effectively computing the transitive
closure of the superclass relation. This implies that this procedure can only
terminate when the superclass relation is represented by a directed acyclic
graph.

In the presense of functional dependencies type class contexts also bring type
equalities into scope for each functional dependency of the class.
\begin{verbatim}
class C a b | a -> b
f :: C Int b => b -> Bool
\end{verbatim}
In this example, the constraint \texttt{C Int b} and the functional dependency
of the class \texttt{C} would give rise to the given equality constraint
\texttt{$F_C$(Int) $\sim$ b}.

Like most procedures in this chapter, it's result has a System $F_C$
counterpart. It generates Match Contexts, which are case expressions with a
single match and a hole.
\begin{figure}[h]
$$
\mathbb{E} ::= \square \mid \textbf{case} \; d \; \textbf{of} \; K \;
(\overline{b : k}) \; (\overline{c : \psi}) \; (\overline{x : v}) \; \rightarrow
\mathbb{E}
$$
\end{figure}
We denote match contexts with $\mathbb{E}$ and $\mathbb{E}[t]$ is the match
context with the hole replaced with the term $t$.

For every class constraint, we recursively pattern match on each corresponding
type class dictionary, bringing the super class dictionaries and FD-induced
coercions and existential type variables in scope.

Lastly, it provides an extended typing environment containing the exposed type
variables and type class methods.

\begin{figure}
\begin{mathpar}
\inferrule*[right=Hole]
{
}
{
    \Gamma \vdash_{\mathbb{E}} \bullet \rightsquigarrow \square \mid \bullet
    \mid \Gamma
}
\\
% TODO kind b'
\inferrule*[right=MCtx]
{
    \textbf{class} \; \forall \overline{a} \overline{b}. \overline{\pi}
    \Rightarrow TC \; \overline{a} \mid \overline{fd} \; \textbf{where} \; f ::
    \sigma
    \\
    fd_i \equiv \overline{a}^{i_n} \rightarrow a_{i_0}
    \\
    \overline{d}, \overline{c}, \overline{b'}, f' \; \text{fresh}
    \\
    \overline{\Gamma \vdash_{cc} \pi \rightsquigarrow \tau}
    \\
    \Gamma \vdash_{ty} \sigma \rightsquigarrow v
    \\
    \phi_i = F_{TC_i}(\overline{a}^{i_n}) \sim a_{i_0}
    \\
    \overline{\Gamma \vdash_{eq} \phi \rightsquigarrow \psi}
    \\
    \theta = [ \overline{a} \mapsto \overline{u}, \overline{b} \mapsto
    \overline{b'}]
    \\
    \Gamma,f': \theta(\sigma), \overline{b'} \vdash_{\mathbb{E}} \overline{d : \theta(\pi)}, \mathcal{P}
    \rightsquigarrow \mathbb{E}' \mid \mathcal{C}_g' \mid \Gamma'
    \\
    \mathbb{E} = \textbf{case} \; d \; \textbf{of} \; K_{TC} \; \overline{b'} \;
    (\overline{c : \theta(\psi)}) \; (\overline{d : \theta(\tau)}) \; (f' :
    \theta(v)) \rightarrow \mathbb{E}'
}
{
    \Gamma \vdash_{\mathbb{E}} (d : TC \; \overline{u}),\mathcal{P}
    \rightsquigarrow \mathbb{E} \mid \overline{c : \theta(\phi)}, \overline{d :
    \theta(\pi)}, \mathcal{C}_g' \mid \Gamma'
}
\end{mathpar}
\caption{Match Contexts}
\end{figure}
\section{Class Elaboration}
%TODO refer to \ref{fig:class}
Because type classes are represented by dictionaries in System $F_C$ at runtime,
a class declaration gives rise to an $F_C$ data declaration for this dictionary.
The type of the data constructor reflects what will be stored in this
dictionary.  As expected it stores the instance method with type $v$ and the
super class dictionaries of types $\overline{\tau}$.

The method type of specified in the declaration does not entirely correspond
with the actual method type. The resulting type is modified to include the type
class of the declaration as a class constraint.

The method implementation simply matches on the type class dictionary to extract
the actual method within.

There are two interesting additions. The first is that for each functional
dependency $fd_i$ , a corresponding type family declaration $F_{TC_i}$ is
generated as well as a type equality that maps the domain of the functional
dependency to the range. The latter is used as the type for the coercions stored
in the dictionary.

Second, the class declaration can contain existential type variables denoted by
$\overline{b}$. These are type variables that appear the context
$\overline{\pi}$ but not in the type class parameters $\overline{a}$. With
functional dependencies these existential variables are not necessarily
ambiguous. These existential types are put in the type class dictionary as well.
More on ambiguousness is explained in chapter~\ref{cha:conditions}.

Notice that, unlike many previous formalizations of type classes, type class
declarations to not extend the program theory for the reasons explained in
section \ref{sec:match-contexts}.
\begin{figure}
\begin{mathpar}
% TODO kinds
% TODO too huge
% TODO conditions as seperate rules
% TODO type families should end up in the environment?
\inferrule*[right=Class]
{
    \overline{c}, \overline{d}, x \; \text{fresh}
    \\
    \Gamma, \overline{a} \vdash_{ty} \sigma \rightsquigarrow v
    \\
    \overline{\Gamma, \overline{a}, \overline{b} \vdash_{cc} \pi
    \rightsquigarrow \tau}
    \\
    fd_i \equiv \overline{a}^{i_n} \rightarrow a_{i_0}
    \\
    \psi_i = F_{TC_i}(\overline{a}^{i_n}) \sim a_{i_0}
    \\
    \sigma \equiv \forall \overline{a'}. \overline{\pi'} \Rightarrow \tau'
    \\
    \sigma_{real} = \forall \overline{a} \overline{a'}. \; TC \; \overline{a} \Rightarrow
    \overline{\pi'} \Rightarrow \tau'
    \\
    \Gamma \vdash_{ty} \sigma_{real} \rightsquigarrow v_{real}
    \\
    t_f = \Lambda \overline{a} \overline{a'}. \lambda(d : T_{TC} \; \overline{a}). \textbf{case}
    \; d \; \textbf{of} \; K_{TC} \; \overline{b} \; (\overline{c : \psi}) \;
    (\overline{d : \pi}) \; (x : v) \rightarrow x \; \overline{a'}
    \\
    \overline{decl_c} =
    [\textbf{data} \; T_{TC} \; \overline{a} \;
    \textbf{where} \; K_{TC} \colon \forall \overline{a} \overline{b}. \;
    \overline{\psi} \Rightarrow \overline{\tau} \rightarrow v \rightarrow T_{TC}
    \; \overline{a}
    , \overline{\textbf{type} \, F_{TC_i} \; \overline{a}^{i_n}}^m
    , \textbf{let} \; f : v_{real} = t_f
    ]
}
{
    \Gamma \vdash_{cls} \textbf{class} \; \forall \overline{a} \overline{b} .
    \overline{\pi} \rightarrow TC \; \overline{a} \mid \overline{fd}^m
    \textbf{where} \; f :: \sigma \rightsquigarrow \overline{decl_c} \mid [ f :
    \sigma_{real} ]
}
\end{mathpar}
\caption{Class Elaboration}
\label{fig:class}
\end{figure}

\section{Instance Elaboration}
Most of the heaving lifting and FD-related things are handled by match
contexts~\ref{sec:conditions} and the superclass
entailment~\ref{fig:superclass-entailment} and axiom
generation~\ref{fig:axiomgen} rules.

Note that the $tm$ judgement has been given a type signature instead of
it being the result of the judgement. This is handled by the subsumption
rule~\ref{fig:subsumption}.
\subsection{Axiom Generation}
As mentioned in section~\ref{sec:fundeps}, every instance declaration gives rise
to top-level type family axioms for each functional dependency.
% TODO liberal coverage condition with conditions?
\subsection{Superclass Entailment}


\subsection{Type Subsumption}
%TODO untouchables \overline{a} passed to entailment
%TODO quote subsumption?
For type checking expressions which are explicitly typed, we employ a procedure
called \textit{type subsumption}. We say that a polytype $\sigma_1$
\textit{subsumes} $\sigma_2$ if any expression of type $\sigma_1$ can also be
assigned the type $\sigma_2$. This concept is also found in systems with
subtyping, like object-oriented languages, where we can instead assign a
supertype of the expressions actual type. In Haskell however, this means that
the type $\sigma_2$ is less general or polymorphic than $\sigma_1$.
%TODO outsidein(x) definition 3.3

In practice, this means that we elaborate the term and infer a type, add a
constraint that says that the monotype component in the provided type signature
should be equal to the inferred type, and add the class constraints in the
signature as given class constraints before constraint entailment. Or in other
words, the term should have the monotype in the signature under the assumption
that the class constraints are satisfied.

In addition to the class constraints in the signature, we also add the
transitive closure of the superclass relation and the FD-induced type equalities
using match contexts.
\begin{figure}
\begin{mathpar}
\inferrule*[right=Instance]
{
    d_I, \overline{d} \; \text{fresh}
    \\
    \Gamma \vdash_{\mathbb{E}} (\overline{d : \pi}) \rightsquigarrow \mathbb{E}
    \mid P_{\mathbb{E}} \mid \Gamma_{\mathbb{E}}
    \\
    P_I = P, P_{ax}, \overline{d : \pi}, P_{\mathbb{E}}
    \\
    \Gamma_I = \Gamma_{\mathbb{E}}, \overline{a}, \overline{b}
    \\
    S_I = \forall \overline{a} \overline{b}. \; \overline{\pi} \Rightarrow TC \;
    \overline{u}
    \\
    \overline{\Gamma, \overline{a}, \overline{b} \vdash_{cc} \pi
    \rightsquigarrow \tau}
    \\
    (f : \forall \overline{a'} \overline{b'}. \; TC \; \overline{a'}
    \Rightarrow \overline{\pi'} \Rightarrow \tau) \in \Gamma
    \\
    P_I, d_I : S_I; \Gamma_I \vdash_{tm} e : [\overline{a'} \mapsto
    \overline{u}] (\forall \overline{b'}. \; \overline{\pi'} \Rightarrow \tau)
    \rightsquigarrow t
    \\
    S_I \hookrightarrow P_{ax}
    \\
    P_I \vdash_{sc} TC \; \overline{u} \rightsquigarrow
    (\overline{\tau_b}, \overline{\gamma_c}, \overline{t_d})
}
{
    P; \Gamma \vdash_{inst} \textbf{instance} \; \forall \overline{a}
    \overline{b}. \overline{\pi} \Rightarrow TC \; \overline{u} \;
    \textbf{where} \; f = e \\
    \rightsquigarrow [ \overline{\textbf{axiom} \; P_{ax}} , d_I :: \forall
    \overline{a} \overline{b}. \;  \overline{\tau} \rightarrow T_{TC} \;
    \overline {u} = \Lambda \overline{a} \overline{b}. \; \lambda\overline{(d :
    \tau)}. \; \mathbb{E}[K_{TC} \; \overline{u} \; \overline{\tau}_b \;
    \overline{\gamma}_c \; \overline{t}_d \; t]] \mid [P_{ax}, d_I : S_I]
}
\end{mathpar}
\caption{Instance Elaboration}
\end{figure}

\begin{figure}
\begin{mathpar}
\inferrule*[right=SC]
{
    \textbf{class} \; \forall \overline{a} \overline{b}. \; \overline{\pi}
    \Rightarrow TC \; \overline{a} \mid \overline{fd}^m
    \\
    \overline{c}, \overline{d} \; \text{fresh}
    \\
    \theta = [\overline{a} \mapsto \overline{u}] \cdot det(\overline{a},
    \overline{\pi})
    \\
    P_{int} \vDash (\overline{d : \theta(\pi)}), (\overline{c :
    \theta(F_{TC_i}(\overline{a}^{i_n}) \sim a_{i_0})}) \rightsquigarrow
    \bullet, \theta_s, \eta_s
}
{
    P_{int} \vdash_{SC} (TC \; \overline{u}) \rightsquigarrow
    (\theta_s(\theta(\overline{b})), \eta_s(\overline{c}), \eta_s(\overline{d}))
}
\end{mathpar}
\caption{Superclass Entailment}
\label{fig:superclass-entailment}
\end{figure}

\begin{figure}
% TODO mention or put in rule how to get instatiated fundep types
\begin{mathpar}
\inferrule*[right=AxiomGen]
{
    (fd_i \equiv \overline{a}^{i_n} \rightarrow a_{i_0}) \in (\overline{fd}^m
    \in TC)
    \\
    \overline{g} \; \text{fresh}
    \\
    \theta_i = det(fv(\overline{u}^{i_n}), \overline{\pi})
    \\
    fv(\theta_i(u_{i_0})) \subseteq fv(\overline{u}^{i_n})
}
{
    (\forall \overline{a} \overline{b}. \; \overline{\pi} \Rightarrow TC \;
    \overline{u}) \hookrightarrow \overline{g_i(fv(\overline{u}^{i_n})) :
    F_{TC_i}(\overline{u}^{i_n}) \sim \theta_i(u_{i_0})}^m
}
\end{mathpar}
\caption{Axiom Generation}
\label{fig:axiomgen}
\end{figure}

\begin{figure}
\begin{mathpar}
\inferrule*[right=Subsumption]
{
    \Gamma \vdash_{tm} e : \tau_1 \rightsquigarrow t \mid \mathcal{P}; \mathcal{E}
    \\
    \Gamma \vdash_{ty} (\forall \overline{a}. \; \overline{\pi} \Rightarrow
    \tau_2)
    \\
    \overline{\Gamma \vdash_{cc} \pi \rightsquigarrow \tau}
    \\
    c, \overline{d} \; \text{fresh}
    \\
    \Gamma \vdash_{\mathbb{E}} (\overline{d : \pi}) \rightsquigarrow \mathbb{E}
    \mid P_{\mathbb{E}} \mid \Gamma_{\mathbb{E}}
    \\
    P, (\overline{d : \pi}),P_{\mathbb{E}} \vDash \mathcal{P}, \mathcal{E},
    (c : \tau_1 \sim \tau_2) \rightsquigarrow \bullet; \theta; \eta
}
{
    P; \Gamma \vdash_{tm} e : (\forall \overline{a}. \; \overline{\pi}
    \Rightarrow \tau_2) \rightsquigarrow \Lambda \overline{a}. \;
    \lambda(\overline{d : \tau}). \; \mathbb{E}[\theta(\eta(t \triangleright c))]
}
\end{mathpar}
\caption{Type Subsumption}
\label{fig:subsumption}
\end{figure}
