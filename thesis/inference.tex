\chapter{Inference and Elaboration}
\label{cha:inference}
Like most systems similar to Hindley-Milner\cite{hindley}\cite{damas-milner},
type inference occurs in two
distinct phases. The first involves constraint generation, and the second
involves solving those constraints. The latter will be discussed in
chapter~\ref{cha:entailment} about constraint entailment.

During constraint generation the Haskell code is simultaneously elaborated into
\systemfc. However, even though \systemfc~is an explicitly typed language,
the types it should be annotated with are not yet known. Therefore every
expression will be assigned a "placeholder" unification type variable that might
be substituted with the actual type after the constraints have been solved.

A similar approach is used for type classes. As mentioned previously, type
classes are elaborated into \systemfc~as dictionary terms that hold the class
methods. Because these are also not yet known, placeholder dictionary variables
are used instead.

%TODO explain fd's after generation, call it determinacy

\section{Source Syntax}
\begin{figure}
\begin{align*}
    a, b, \alpha, \beta &::= \; \langle type \; variable \rangle \\
    x, f                &::= \; \langle term \; variable \rangle \\
    T                   &::= \; \langle type \; constructor \rangle \\
    K                   &::= \; \langle data \; constructor \rangle \\
    TC                  &::= \; \langle class \; constructor \rangle \\
    F                   &::= \; \langle type \; family \rangle \\
    \\
    pgm &::= \overline{decl} &program\\
    decl &::= cls \mid inst \mid data \mid val &declaration\\
    cls &::= \textbf{class} \; \forall \overline{a} \overline{b}. \;
    \overline{\pi} \Rightarrow TC \; \overline{a} \mid \overline{fd}^m
    \textbf{where} \; f :: \sigma &class\\
    inst &::= \textbf{instance} \; \forall \overline{a} \overline{b}. \;
    \overline{\pi} \Rightarrow TC \; \overline{u} \; \textbf{where} \; f = e
    &instance\\
    data &::= \textbf{data} \; T \; \overline{a} = \overline{K \; \overline{a}
    \;} &data\\
    val &::= x = e \mid x :: \sigma = e &value \; binding\\
    fd &::= a_1, \mathellipsis, a_n \rightarrow a_0 &fundep\\
    \\
    e &::= x \mid K \mid e_1 \; e_2 \mid \lambda x. \; e \mid \textbf{let} \; x
    = e_2 \; \textbf{in} \; e_2 \\
    &\quad \mid \textbf{case} \; e_{scr} \; \textbf{of} \; \overline{K \; \overline{x}
    \rightarrow e} &term \\
    \\
    \sigma &::= \rho \mid \forall a. \; \sigma &polytype \\
    \rho &::= \tau \mid \pi \Rightarrow \rho &qualified \; type \\
    \tau &::= a \mid T \mid \tau_1 \; \tau_2 \mid F(\overline{\tau})
         &monotype \\
    u &::= a \mid T \mid u_1 \; u_2 &type \; pattern \\
    \\
    \pi &::= TC \; \overline{\tau} &class \; constraint \\
    \\
\end{align*}
%TODO put scheme and equality constraint with inference syntax?
\caption{Source syntax}
\label{fig:source-syntax}
\end{figure}
The syntax of our Haskell-like source programs is given in
figure~\ref{fig:source-syntax}. It is highly similar to Haskell '98 except for
several additions and simplifications. Type classes can have
multiple type parameters instead of one. In class and instance declarations we
differentiate between $\overline{a}$, the type variables that occur in the type
class parameters, and $\overline{b}$, the type variables that solely occur in the
context $\overline{\pi}$. Reason being that this doesn't have to be an issue if
these $\overline{b}$ can be uniquely determined by functional dependencies.

Class declarations can now be annotated with functional dependencies of the form
$a_1, \mathellipsis, a_n \rightarrow a_0$, where $a_1, \mathellipsis, a_n$ is
commonly referred to the \textit{domain} and $a_0$ as the \textit{range} of the
functional dependency. GHC allows for functional dependencies of the form $a
\rightarrow b \; c$ with multiple types to the right of the arrow. These are
called \textit{multi-range} functional dependencies, but these can be translated
into the \textit{single-range} variant \cite{fundeps-chrs} and are therefore not
considered in this work.

Expressions consist of a simple $\lambda$-calculus extended with algebraic data
types and let expressions.

%TODO more about type families?
Monotypes have been extended with type family applications $F(\overline{\tau})$
\cite{associated-types-with-class} similar to \systemfc. These are not
allowed in the source text and are only used internally. Therefore, we also
define type patterns denoted by $u$. These are simple monotypes that do not
contain any type families. On top of monotypes we have qualified types and
polytypes. Even though GHC allows types to be qualified with equality
constraints in addition to type class constraints, we only allow class
constraints for simplicity. Note that there is no mention of arrow types, these
are considered type constructors. The type $a \rightarrow b$ would in practice
look like $((\rightarrow) \; a) \; b$ with $(\rightarrow)$ a primitive for the
arrow type constructor.

\begin{figure}
\begin{align*}
    P &::= \langle \mathcal{S}, \mathcal{A}, \mathcal{C}_g \rangle &program \;
    theory
    \\
    \\
    \mathcal{C} &::= \bullet \mid \mathcal{C}, d : \pi \mid \mathcal{C}, c
    : \phi &wanted \; constraints
    \\
    \mathcal{P} &::= \bullet \mid \mathcal{P}, d : \pi &wanted \; class \;
    constraints
    \\
    \mathcal{E} &::= \bullet \mid \mathcal{E}, c : \phi &wanted \; equality
    \; constraints
    \\
    \\
    \mathcal{C}_g &::= \bullet \mid \mathcal{C}_g, t : \pi \mid \mathcal{C}_g,
    \gamma: \phi &given \; constraints
    \\
    \\
    \mathcal{A} &::= \bullet \mid \mathcal{A}, g \; \overline{a} :
    F(\overline{u}) \sim \tau &equality \; axioms
    \\
    \mathcal{S} &::= \bullet \mid \mathcal{S}, d : S &annotated \; constraint \;
    schemes
    \\ 
    \\
    \phi &::= \tau_1 \sim \tau_2 &equality \; constraint
    \\
    S &::= \forall \overline{a}. \overline{\pi} \Rightarrow \pi &constraint \;
    scheme
    \\
    \\
    \eta &::= \bullet \mid [d \mapsto t] \cdot \eta \mid [c \mapsto \gamma]
    \cdot \eta &evidence \; substitution
    \\
    \theta &::= \bullet \mid [\alpha \mapsto \tau] \cdot \theta &type \;
    substitution
    \\
    \Gamma &::= \bullet \mid \Gamma, x : \sigma \mid \Gamma, a : k &typing \; environment
    \\
    \\
    d &::= \langle dictionary \; variable \rangle
\end{align*}
\caption{Inference syntax}
\label{fig:inference-syntax}
\end{figure}
\subsection{Inference Syntax}
Figure~\ref{fig:inference-syntax} describes additional syntax used by the type
checker during inference.

Constraint schemes $S$ capture implications generated by instance declarations
and unlike many other formalizations not by class declarations. Equality
constraints denoted by $\phi$ are of the form $\tau_1 \sim \tau_2$ which simply
means that type $\tau_1$ should be equal to $\tau_2$. As we will see in
section~\ref{sec:instance-elaboration}, functional dependencies give rise to
equality axioms, denoted by $\mathcal{A}$. These are simply the Haskell
counterpart to \systemfc top-level equality axioms and are semantically
equivalent, note that $g$ is an $\text{F}_\text{C}$  ~axiom variable in either case. Class
constraints, equality constraints and constraint schemes can be annotated with
evidence, which are dictionary variables, coercion variables and again
dictionary variables respectively. Sets of these are denoted with the
calligraphic $\mathcal{P}$, $\mathcal{E}$ and $\mathcal{S}$ respectively. A set
of both annotated class and equality constraints are denoted by $\mathcal{C}$.
When these constraints are given constraints we use subscript $g$ and these can
be annotated with full $\text{F}_\text{C}$ terms and coercions. This won't make
a difference during constraint generation but has it's use during entailment.

The program theory, denoted by $P$ is a triple of annotated constraint schemes,
equality axioms and a set of local given constraints. It gathers the all of the
constraints schemes and equality axioms from instance declarations and the local
given constraints when under a qualified type or context.

The typing environment is standard and stores types of term variables and type
variables with their kinds.

\input{determinacy}

\section{Constraint Generation}
\label{sec:constraint-generation}
\begin{figure}[h]
% TmVar
%TODO include \notin dom
%TODO fix fd constraints
\fbox{$\Gamma \vdash_{tm} e : \tau \rightsquigarrow t \mid \mathcal{C}$}
\begin{mathpar}
\inferrule*[right=TmVar]
{
    (x : \forall \overline{a} \overline{b}. \overline{\pi} \Rightarrow \tau) \in
    \Gamma
    \\
    \overline{\alpha},\overline{d} \; \text{fresh}
    \\
    \theta = [ \overline{\alpha} \mapsto \overline{a}] \; \cdot \;
    det(\overline{a},\overline{\pi})
    \\
    TC \; \overline{\tau} \in \theta(\overline{\pi})
    \\
    TC \; \overline{a}' \mid a_{i_1}', \mathellipsis, a_{i_n}' \rightarrow
    a_{i_0}'
}
{
    \Gamma \vdash_{tm} x : \theta(\tau) \rightsquigarrow x \; \overline{\alpha}
    \; \theta(\overline{b}) \; \overline{d} \; | \; \overline{d :
    \theta(\pi)}, \overline{F_{TC}(\overline{\tau}^{i_n}) \sim \tau_{i_0}}
}
\\
% TmAbs
\inferrule*[right=TmAbs]
{
    \Gamma, x : \alpha \vdash_{tm} e : \tau \rightsquigarrow t \; | \; \mathcal{C}
    \\
    \alpha \; \text{fresh}
}
{
    \Gamma \vdash_{tm} \lambda x. e : ( \alpha \rightarrow \tau) \rightsquigarrow
    \lambda (x : \alpha) . t \; | \; \mathcal{C}
}
\\
% TmApp
\inferrule*[right=TmApp]
{
    \Gamma \vdash_{tm} e_1 : \tau_1 \; | \; \mathcal{C}_1
    \\
    \Gamma \vdash_{tm} e_2 : \tau_2 \; | \; \mathcal{C}_2
    \\
    \alpha, c \; \text{fresh}
}
{
    \Gamma \vdash_{tm} e_1 \; e_2 : a \rightsquigarrow (t_1 \triangleright c) \; t_2
    \; | \; \mathcal{C}_1, \mathcal{C}_2, c : \tau_1 \sim (\tau_2 \rightarrow \alpha)
}
\\
% TmLet
\inferrule*[right=TmLet]
{
    \Gamma, x : \alpha \vdash_{tm} e_1: \tau_1 \rightsquigarrow t_1 \; | \;
    \mathcal{C}_1
    \\
    \Gamma, x : \alpha \vdash_{tm} e_2: \tau_2 \rightsquigarrow t_2 \; | \;
    \mathcal{C}_2
    \\
    \alpha, c \; \text{fresh}
}
{
    \Gamma \vdash_{tm} (\textbf{let} \; x = e_1 \; \textbf{in} \; e_2) : \tau_2
    \rightsquigarrow (\textbf{let} \; x : \tau_1 = t_1 \; \textbf{in} \; t_2) \;
    | \; \mathcal{C}_1, \mathcal{C}_2, c : \alpha \sim \tau_1
}
\\
% TmCon
\inferrule*[right=TmCon]
{
    (K : \forall \overline{a} . \tau) \in \Gamma
    \\
    \overline{\beta} \; \text{fresh}
}
{
    \Gamma \vdash_{tm} K : [ \overline{a \mapsto \beta}] \tau
    \rightsquigarrow K \; \overline{\beta} \; | \; \bullet
}
\\
% TmCase
\inferrule*[right=TmCase]
{
    \Gamma \vdash_{tm} e_{scr} : \tau_{scr} \rightsquigarrow t_{scr} \mid
    \mathcal{C}_{scr}
    \\
    \alpha, \overline{\beta}, c, \overline{c'} \; \text{fresh}
    \\
    (K_i : \forall \overline{a}. \overline{\tau}^i \rightarrow T \; \overline{a})
    \in \Gamma
    \\
    \Gamma, \overline{x_i : [\overline{a \mapsto \beta}]\tau_i} \vdash_{tm} e_i
    : \tau_{e_i} \rightsquigarrow t_{e_i} \mid \mathcal{C}_{e_i}
}
{
    \Gamma \vdash_{tm} \textbf{case} \; e_{scr} \; \textbf{of} \; \overline{K \;
    \overline{x} \rightarrow e} : \alpha \rightsquigarrow \textbf{case} \;
    t_{scr} \triangleright c \; \textbf{of} \; \overline{K \; \overline{x}
    \rightarrow t_e \triangleright c'}
    \\
    \mid \mathcal{C}_{scr}, \overline{\mathcal{C}_e}, c : \tau_{scr} \sim T
    \; \overline{\beta}, \overline{c' : \tau_e \sim \alpha}
}
\end{mathpar}
\label{fig:ct-generation}
\caption{Term Elaboration and Constraint Generation}
\end{figure}
%TODO mention let generalization here
%TODO talk about freshening in general?
Figure~\ref{fig:ct-generation} specifies constraint generation and elaboration
of expressions into \systemfc. The judgement takes a typing environment $\Gamma$
and a expression $e$ and provides a monotype and a set of annotated wanted
constraints.

This is the first time we encounter the concept of \textit{freshening}. When
something is drawn from the typing environment or a declaration, we must be
careful to substitute all type variables bound by type abstractions with newly
generated ones. Otherwise, when this is done multiple times and the same
variables from the environment are used, the constraint solver might come to the
incorrect conclusion that these should be instantiated with the same type. This
concept will recur often in the rest of this thesis.

\begin{itemize}

  \item Rule \texttt{TmVar} is the most interesting case. Firstly, the type variables
$\overline{b}$, those that are bound solely by $\overline{\pi}$, are not
freshened but instead the determinacy relation is used to represent them in
terms of $\overline{a}$. Consider the following example:
\begin{verbatim}
    class C a b | a -> b
    f :: C a b => a -> a
\end{verbatim}
For any occurrence of the function \texttt{f} we infer the type $\alpha
\rightarrow \alpha$ and give rise to the wanted constraint $C \; \alpha \;
F_C(\alpha)$

%TODO not convinced this does not make determinacy obsolete in this rule
% creating C a F(a) would get flattened to C a b, F(a) ~ b anyway, which would
% be equivalent to instead generating C a b, F(a) ~ b
Secondly, and this is where our system differs from that of Karachalias et
al.\cite{Karachalias:2017:EFD:3156695.3122966}, we introduce wanted constraints
for every functional dependency of every type class constraint in
$\theta(\overline{\pi})$. This is done to guide the constraint entailment
algorithm to resolve any possible ambiguities that can be determined by
functional dependencies. Why this is required will be discussed
Section~\ref{sec:wanted-fd-constraints}.
%TODO this requires some knowledge about subsumption

\item Rule \texttt{TmAbs} handles abstractions and is entirely standard.

\item For rule \texttt{TmLet}, as proposed by Vytiniotis et
al.~\cite{vytiniotis}, we have opted for non-generalized, possibly recursive
let-bindings so not to complicate things too much.

\item Rule \texttt{TmApp} handles applications and is mostly standard. The fresh
coercion variable $c$ in the constraint $c : \tau_1 \sim (\tau_2 \rightarrow
\alpha)$ is used to explicitly type cast the left component $t_1$. The type of
$t_1$ and $t_2$ might not be syntactically equivalent and when this constraint is
solved, $c$ will be replaced with evidence of this equality.

\item For rule \texttt{TmCase}, we abuse the fact that our system allows for only very
simple pattern matching. Every case is a simple pattern with single data
constructor. This implies we can manually type check each constructor $K_i$ and
verify that each has a return type with the same type constructor $T$. It allows
us to create a single constraint $c : \tau_{scr} \sim T \; \overline{beta}$ for
the type of the scrutinee $\tau_{scr}$ instead of a constraint for every case.
Having a single annotated constraint allows us to use a single coercion variable
$c$ to type cast the elaborated scrutinee $t_{scr}$. The result type of every case
alternative $\tau_{e_i}$ is also type cast to the same result type $\alpha$.

\end{itemize}
\section{Match Contexts}
\label{sec:match-contexts}
% TODO rename dictDestruction? no longer defined in terms of dictionary brings
% TODO mention that we can't use superclass projections for coercions
% everything context related in scope
% Explain type class dictionaries
%TODO examples
\begin{figure}
\fbox{$\Gamma \vdash_{\mathbb{E}} \mathcal{P} \rightsquigarrow \mathbb{E}
       \mid \mathcal{C}_g \mid \Gamma$}
\begin{mathpar}
\inferrule*[right=Hole]
{
}
{
    \Gamma \vdash_{\mathbb{E}} \bullet \rightsquigarrow \square \mid \bullet
    \mid \Gamma
}
\\
% TODO kind b'
\inferrule*[right=MCtx]
{
    \textbf{class} \; \forall \overline{a} \overline{b}. \overline{\pi}
    \Rightarrow TC \; \overline{a} \mid \overline{fd} \; \textbf{where} \; f ::
    \sigma
    \\
    fd_i \equiv \overline{a}^{i_n} \rightarrow a_{i_0}
    \\
    \overline{d}, \overline{c}, \overline{b'}, f' \; \text{fresh}
    \\
    \overline{\Gamma \vdash_{cc} \pi \rightsquigarrow \tau}
    \\
    \Gamma \vdash_{ty} \sigma \rightsquigarrow v
    \\
    \phi_i = F_{TC_i}(\overline{a}^{i_n}) \sim a_{i_0}
    \\
    \overline{\Gamma \vdash_{eq} \phi \rightsquigarrow \psi}
    \\
    \theta = [ \overline{a} \mapsto \overline{u}, \overline{b} \mapsto
    \overline{b'}]
    \\
    \Gamma,f': \theta(\sigma), \overline{b'} \vdash_{\mathbb{E}} \overline{d : \theta(\pi)}, \mathcal{P}
    \rightsquigarrow \mathbb{E}' \mid \mathcal{C}_g' \mid \Gamma'
    \\
    \mathbb{E} = \textbf{case} \; d \; \textbf{of} \; K_{TC} \; \overline{b'} \;
    (\overline{c : \theta(\psi)}) \; (\overline{d : \theta(\tau)}) \; (f' :
    \theta(v)) \rightarrow \mathbb{E}'
}
{
    \Gamma \vdash_{\mathbb{E}} (d : TC \; \overline{u}),\mathcal{P}
    \rightsquigarrow \mathbb{E} \mid \overline{c : \theta(\phi)}, \overline{d :
    \theta(\pi)}, \mathcal{C}_g' \mid \Gamma'
}
\end{mathpar}
\caption{Match Contexts}
\end{figure}

This procedure deals with bringing relevant structures in scope related
to type class contexts. It brings super classes in scope and type equalities
introduced by functional dependencies. Consider the following example:
\begin{verbatim}
    class Eq a => Ord a
    sort :: Ord a => [a] -> [a]
\end{verbatim}
In this example, \texttt{Eq} is a superclass of \texttt{Ord}. Because having
implemented an instance for \texttt{Eq} is a prerequisite for \texttt{Ord}, we
should read the implication arrow in the class declaration in the other
direction. If we know that there is an instance for \texttt{Ord}, then we can
assume there is one for \texttt{Eq} as well. We could add the \texttt{Ord a =>
Eq a} implication to the program theory as is. But this implication would
always overlap with those from the instance declarations which would make
solving type class constraints non-deterministic.

The solution is to preemptively add the instantiated super class constraints
from the context as given class constraints. And we do the same with the
superclasses of the superclasses effectively computing the transitive closure of
the superclass relation. This implies that this procedure can only terminate
when the superclass relation can be represented by a directed acyclic graph.

In the presense of functional dependencies type class contexts also bring type
equalities into scope for each functional dependency of the class.
\begin{verbatim}
class C a b | a -> b
f :: C Int b => b -> Bool
\end{verbatim}
In this example, the constraint \texttt{C Int b} and the functional dependency
of the class \texttt{C} would give rise to the given equality constraint
\texttt{$F_C$(Int) $\sim$ b}.

Like most procedures in this chapter, its result has a \systemfc
counterpart. It generates Match Contexts, which are case expressions with a
single match and a hole.
\begin{figure}[h]
$$
\mathbb{E} ::= \square \mid \textbf{case} \; d \; \textbf{of} \; K \;
(\overline{b : k}) \; (\overline{c : \psi}) \; (\overline{x : v}) \; \rightarrow
\mathbb{E}
$$
\end{figure}
We denote match contexts with $\mathbb{E}$ and $\mathbb{E}[t]$ is the match
context with the hole replaced with the term $t$.

For every class constraint, we recursively pattern match on each corresponding
type class dictionary, bringing the super class dictionaries and FD-induced
coercions and existential type variables in scope.

Lastly, it provides an extended typing environment containing the exposed type
variables and type class methods\footnote{The methods are put in the environment
for completion's sake but this does not serve any purpose for now.}.

\section{Class Elaboration}
\label{sec:class-elaboration}

\begin{figure}
\fbox{$\Gamma \vdash_{cls} cls \rightsquigarrow \overline{decl} \mid
       \Gamma_c$}
\begin{mathpar}
% TODO kinds
% TODO too huge
% TODO conditions as seperate rules
% TODO type families should end up in the environment?
\inferrule*[right=Class]
{
    \overline{c}, \overline{d}, x \; \text{fresh}
    \\
    \Gamma, \overline{a} \vdash_{ty} \sigma \rightsquigarrow v
    \\
    \overline{\Gamma, \overline{a}, \overline{b} \vdash_{cc} \pi
    \rightsquigarrow \tau}
    \\
    fd_i \equiv \overline{a}^{i_n} \rightarrow a_{i_0}
    \\
    \psi_i = F_{TC_i}(\overline{a}^{i_n}) \sim a_{i_0}
    \\
    \sigma \equiv \forall \overline{a'}. \overline{\pi'} \Rightarrow \tau'
    \\
    \sigma_{real} = \forall \overline{a} \overline{a'}. \; TC \; \overline{a} \Rightarrow
    \overline{\pi'} \Rightarrow \tau'
    \\
    \Gamma \vdash_{ty} \sigma_{real} \rightsquigarrow v_{real}
    \\
    \mbox{$\begin{array}{l@{\hspace{.1cm}}c@{\hspace{.1cm}}l}
    \overline{decl_c} & = &
    [\textbf{data} \; T_{TC} \; \overline{a} \;
    \textbf{where} \; K_{TC} \colon \forall \overline{a} \overline{b}. \;
    \overline{\psi} \Rightarrow \overline{\tau} \rightarrow v \rightarrow T_{TC}
    \; \overline{a} \\
    &  &, \overline{\textbf{type} \, F_{TC_i} \; \overline{a}^{i_n}}^m \\
    &  &, \textbf{let} \; f : v_{real} = \Lambda \overline{a} \overline{a'}.
    \lambda(d : T_{TC} \; \overline{a}). \; \textbf{case} \; d \; \textbf{of} \;
    K_{TC} \; \overline{b} \; (\overline{c : \psi}) \; (\overline{d : \pi}) \;
    (x : v) \rightarrow x \; \overline{a'}
    ]
    \end{array}$}
}
{
    \Gamma \vdash_{cls} \textbf{class} \; \forall \overline{a} \overline{b} .
    \overline{\pi} \rightarrow TC \; \overline{a} \mid \overline{fd}^m
    \textbf{where} \; f :: \sigma \rightsquigarrow \overline{decl_c} \mid [ f :
    \sigma_{real} ]
}
\end{mathpar}
\caption{Class Elaboration}
\label{fig:class}
\end{figure}

%TODO refer to \ref{fig:class}
Because type classes are represented by dictionaries in System $F_C$ at runtime,
a class declaration gives rise to an $F_C$ data declaration for this dictionary.
The type of the data constructor reflects what will be stored in this
dictionary. As expected, it stores the instance method with type $v$ and the
superclass dictionaries of types $\overline{\tau}$.

The method type specified in the declaration does not entirely correspond with
the actual method type. The resulting method type is modified to qualify over
the type class it is a part of.

The method implementation simply matches on the type class dictionary to extract
the actual method within.

There are two interesting additions. The first is that for each functional
dependency $fd_i$ , a corresponding type family declaration $F_{TC_i}$ is
generated as well as a type equality that maps the domain of the functional
dependency to the range. The latter is used as the type for the coercions stored
in the dictionary.

Second, the class declaration can contain existential type variables denoted by
$\overline{b}$. These are type variables that appear the context
$\overline{\pi}$ but not in the type class parameters $\overline{a}$. With
functional dependencies these existential variables are not necessarily
ambiguous. These existential types are put in the type class dictionary as well.
More on ambiguity is explained in chapter~\ref{cha:conditions}.

Unlike many previous formalizations of type classes, type class
declarations to not extend the program theory for the reasons explained in
section \ref{sec:match-contexts}.

\section{Instance Elaboration}
\label{sec:instance-elaboration}

\begin{figure}
    \fbox{$P; \Gamma \vdash_{inst} inst \rightsquigarrow \overline{decl} \mid
    P_i$}
\begin{mathpar}
\inferrule*[right=Instance]
{
    d_I, \overline{d} \; \text{fresh}
    \\
    \Gamma \vdash_{\mathbb{E}} (\overline{d : \pi}) \rightsquigarrow \mathbb{E}
    \mid P_{\mathbb{E}} \mid \Gamma_{\mathbb{E}}
    \\
    P_I = P, P_{ax}, \overline{d : \pi}, P_{\mathbb{E}}
    \\
    \Gamma_I = \Gamma_{\mathbb{E}}, \overline{a}, \overline{b}
    \\
    S_I = \forall \overline{a} \overline{b}. \; \overline{\pi} \Rightarrow TC \;
    \overline{u}
    \\
    \overline{\Gamma, \overline{a}, \overline{b} \vdash_{cc} \pi
    \rightsquigarrow \tau}
    \\
    (f : \forall \overline{a'} \overline{b'}. \; TC \; \overline{a'}
    \Rightarrow \overline{\pi'} \Rightarrow \tau) \in \Gamma
    \\
    P_I, d_I : S_I; \Gamma_I \vdash_{tm} e : [\overline{a'} \mapsto
    \overline{u}] (\forall \overline{b'}. \; \overline{\pi'} \Rightarrow \tau)
    \rightsquigarrow t
    \\
    S_I \hookrightarrow P_{ax}
    \\
    P_I \vdash_{sc} TC \; \overline{u} \rightsquigarrow
    (\overline{\tau_b}, \overline{\gamma_c}, \overline{t_d})
}
{
    P; \Gamma \vdash_{inst} \textbf{instance} \; \forall \overline{a}
    \overline{b}. \overline{\pi} \Rightarrow TC \; \overline{u} \;
    \textbf{where} \; f = e \\
    \rightsquigarrow [ \overline{\textbf{axiom} \; P_{ax}} , d_I :: \forall
    \overline{a} \overline{b}. \;  \overline{\tau} \rightarrow T_{TC} \;
    \overline {u} = \Lambda \overline{a} \overline{b}. \; \lambda\overline{(d :
    \tau)}. \; \mathbb{E}[K_{TC} \; \overline{u} \; \overline{\tau}_b \;
    \overline{\gamma}_c \; \overline{t}_d \; t]] \mid [P_{ax}, d_I : S_I]
}
\end{mathpar}
\caption{Instance Elaboration}
\end{figure}

Most of the heavy lifting and FD-related things are handled by match
contexts (Section~\ref{sec:match-contexts}), the superclass
entailment (Figure~\ref{fig:superclass-entailment}), and axiom
generation (Figure~\ref{fig:axiomgen}) rules.

Note that the $tm$ judgement has been given a type signature instead of
it being the result of the judgement. This is handled by the subsumption
rule~\ref{fig:subsumption}.
\subsection{Axiom Generation}

\begin{figure}
\fbox{$\overline{S} \hookrightarrow \mathcal{A}$}
\begin{mathpar}
\inferrule*[right=AxiomGen]
{
    (fd_i \equiv \overline{a}^{i_n} \rightarrow a_{i_0}) \in (\overline{fd}^m
    \in TC)
    \\
    \overline{g} \; \text{fresh}
    \\
    \theta_i = det(fv(\overline{u}^{i_n}), \overline{\pi})
    \\
    fv(\theta_i(u_{i_0})) \subseteq fv(\overline{u}^{i_n})
}
{
    (\forall \overline{a} \overline{b}. \; \overline{\pi} \Rightarrow TC \;
    \overline{u}) \hookrightarrow \overline{g_i(fv(\overline{u}^{i_n})) :
    F_{TC_i}(\overline{u}^{i_n}) \sim \theta_i(u_{i_0})}^m
}
\end{mathpar}
\caption{Axiom Generation}
\label{fig:axiomgen}
\end{figure}

This simple procedure generates instantiated equality axioms for every
functional dependency of type class we have declared an instance for.
The check $fv(\theta_i(u_{i_0})) \subseteq fv(\overline{u}^{i_n})$ verifies if
the resulting axioms are well-formed. This will be further discussed in
Section~\ref{sec:coverage}.

\subsection{Superclass Entailment}

\begin{figure}
\fbox{$P \vdash_{SC} \pi \rightsquigarrow (\overline{\tau}_b,
    \overline{\gamma}_b, \overline{t}_d)$}
\begin{mathpar}
\inferrule*[right=SC]
{
    \textbf{class} \; \forall \overline{a} \overline{b}. \; \overline{\pi}
    \Rightarrow TC \; \overline{a} \mid \overline{fd}^m
    \\
    \overline{c}, \overline{d} \; \text{fresh}
    \\
    \theta = [\overline{a} \mapsto \overline{u}] \cdot det(\overline{a},
    \overline{\pi})
    \\
    P_I \vDash (\overline{d : \theta(\pi)}), (\overline{c :
    \theta(F_{TC_i}(\overline{a}^{i_n}) \sim a_{i_0})}) \rightsquigarrow
    \bullet, \theta_s, \eta_s
}
{
    P_I \vdash_{SC} (TC \; \overline{u}) \rightsquigarrow
    (\theta_s(\theta(\overline{b})), \eta_s(\overline{c}), \eta_s(\overline{d}))
}
\end{mathpar}
\caption{Superclass Entailment}
\label{fig:superclass-entailment}
\end{figure}

When we define an instance declaration, we have to make sure that an instance
for the superclass of this particular type class can be derived as well.
\[
\begin{array}{l@{\hspace{2cm}}l}
    \texttt{class Eq a} &\texttt{instance Eq Int}
    \\
    \texttt{class Eq a => Ord a} &\texttt{instance Ord Int}
    \\
    \\
    \texttt{instance Eq a => Eq [a]} &\texttt{instance Ord a => Ord [a]}
\end{array}
\]

In the simplest case, defining and instance declaration for \texttt{Ord Int}
would require us to define one for \texttt{Eq Int} as well. We can take this a
step further to \texttt{Ord [a]} and \text{Eq [a]}. But if we were to define an
instance for \texttt{Ord [Int]} instead:

\[
\begin{array}{l@{\hspace{2cm}}l}
    \texttt{instance Eq Int} &\texttt{instance Eq a => Eq [a]}
    \\
    \texttt{instance Ord [Int]}
\end{array}
\]

An instance of the superclass \texttt{Eq [Int]} could be derived by combining
the instance of \texttt{Eq Int} and \texttt{Eq [a]}. To determine these implicit
superclass instances we simply use constraint entailment, which will be
discussed in Chapter~\ref{cha:entailment}, to attempt to completely solve the
instantiated superclasses. All type class constraints in the instance context
and everything else that can be derived from them should be available as given
constraints in $P_I$ as well as the newly generated axioms.

We use the determinacy relation to disambiguate the superclass constraints
first. Additionally we verify the information from instance context $P_I$ is
sufficient to completely solve the functional dependency constraints.

As a solution, constraint entailment provides us with the derived dictionaries
of the superclasses, coercions that prove the functional dependency constraints
and instantiations for the type variables $\overline{b}$. All of these will be
stored in the GADT dictionary of the instance declaration.

\subsection{Type Subsumption}
\label{sec:subsumption}

\begin{figure}
\fbox{$P; \Gamma \vdash_{tm} e : \sigma \rightsquigarrow t$}
\begin{mathpar}
\inferrule*[right=Subsumption]
{
    \Gamma \vdash_{tm} e : \tau_1 \rightsquigarrow t \mid \mathcal{P}; \mathcal{E}
    \\
    \Gamma \vdash_{ty} (\forall \overline{a}. \; \overline{\pi} \Rightarrow
    \tau_2)
    \\
    \overline{\Gamma \vdash_{cc} \pi \rightsquigarrow \tau}
    \\
    c, \overline{d} \; \text{fresh}
    \\
    \Gamma \vdash_{\mathbb{E}} (\overline{d : \pi}) \rightsquigarrow \mathbb{E}
    \mid P_{\mathbb{E}} \mid \Gamma_{\mathbb{E}}
    \\
    P, (\overline{d : \pi}),P_{\mathbb{E}} \vDash \mathcal{P}, \mathcal{E},
    (c : \tau_1 \sim \tau_2) \rightsquigarrow \bullet; \theta; \eta
}
{
    P; \Gamma \vdash_{tm} e : (\forall \overline{a}. \; \overline{\pi}
    \Rightarrow \tau_2) \rightsquigarrow \Lambda \overline{a}. \;
    \lambda(\overline{d : \tau}). \; \mathbb{E}[\theta(\eta(t \triangleright c))]
}
\end{mathpar}
\caption{Type Subsumption}
\label{fig:subsumption}
\end{figure}

%TODO untouchables \overline{a} passed to entailment
%TODO quote subsumption?
For type checking expressions which are explicitly typed, we employ a procedure
called \textit{type subsumption}. We say that a polytype $\sigma_1$
\textit{subsumes} $\sigma_2$ if any expression of type $\sigma_1$ can also be
assigned the type $\sigma_2$. This concept is also found in systems with
subtyping, like object-oriented languages, where we can instead assign a
supertype of the expressions actual type. In Haskell however, this means that
the type $\sigma_2$ is less general or polymorphic than $\sigma_1$.
%TODO outsidein(x) definition 3.3

For example, given an expression \texttt{f} with type \texttt{Eq a => a -> a ->
Bool}, we could instead annotate \texttt{f} with the type \texttt{Int -> Int ->
Bool} because it's less general. \texttt{a} has been instantiated with
\texttt{Int} and \texttt{Eq Int} can be omitted because there is an instance
declaration for it.

In practice, this means that we elaborate the term and infer a type, add a
wanted constraint that says that the monotype component in the provided type
signature should be equal to the inferred type, and add the class constraints in
the signature as given class constraints before constraint entailment. Or in
other words, the term should have the monotype in the signature under the
assumption that the class constraints are satisfied.

In addition to the class constraints in the signature, we also add the
transitive closure of the superclass relation and the FD-induced type equalities
using match contexts.
