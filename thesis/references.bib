@book{JonesThesis,
 author = {Jones, Mark P.},
 title = {Qualified Types: Theory and Practice},
 year = {1995},
 isbn = {0-521-47253-9},
 publisher = {Cambridge University Press},
}

@article{AssociatedTypeSynonyms,
 author = {Chakravarty, Manuel M. T. and Keller, Gabriele and Jones, Simon Peyton},
 title = {Associated Type Synonyms},
 journal = {SIGPLAN Not.},
 issue_date = {September 2005},
 volume = {40},
 number = {9},
 year = {2005},
 issn = {0362-1340},
 pages = {241--253},
 acmid = {1086397},
 publisher = {ACM},
 keywords = {associated types, generic programming, type classes, type functions, type inference},
}

@article{PeytonJones06,
 author = {Peyton Jones, Simon and Vytiniotis, Dimitrios and Weirich, Stephanie and Washburn, Geoffrey},
 title = {Simple Unification-based Type Inference for GADTs},
 journal = {SIGPLAN Not.},
 issue_date = {September 2006},
 volume = {41},
 number = {9},
 year = {2006},
 issn = {0362-1340},
 pages = {50--61},
 numpages = {12},
 acmid = {1159811},
 publisher = {ACM},
 keywords = {generalized algebraic data types, type inference},
}

% Gira89
@book{systemf,
 author = {Girard, Jean-Yves and Taylor, Paul and Lafont, Yves},
 title = {Proofs and Types},
 year = {1989},
 publisher = {Cambridge University Press},
}

@inproceedings{Wadler:1989:MAP:75277.75283,
 author = {Wadler, P. and Blott, S.},
 title = {How to Make Ad-hoc Polymorphism Less Ad Hoc},
 booktitle = {Proceedings of the 16th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
 series = {POPL '89},
 year = {1989},
 isbn = {0-89791-294-2},
 location = {Austin, Texas, USA},
 pages = {60--76},
 numpages = {17},
 url = {http://doi.acm.org/10.1145/75277.75283},
 doi = {10.1145/75277.75283},
 acmid = {75283},
 publisher = {ACM},
 address = {New York, NY, USA},
}

@article{Karachalias:2017:EFD:3156695.3122966,
 author = {Karachalias, Georgios and Schrijvers, Tom},
 title = {Elaboration on Functional Dependencies: Functional Dependencies Are Dead, Long Live Functional Dependencies!},
 journal = {SIGPLAN Not.},
 issue_date = {October 2017},
 volume = {52},
 number = {10},
 month = sep,
 year = {2017},
 issn = {0362-1340},
 pages = {133--147},
 numpages = {15},
 url = {http://doi.acm.org/10.1145/3156695.3122966},
 doi = {10.1145/3156695.3122966},
 acmid = {3122966},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Haskell, System FC, functional dependencies},
}

@inproceedings{Jones00typeclasses,
 author = {Mark P. Jones},
 title = {Type classes with functional dependencies},
 booktitle = {ESOP/ETA (LNCS)},
 year = {2000},
 pages = {230--244},
 publisher = {Springer-Verlag}
}

@inproceedings{Sulzmann:2007:SFT:1190315.1190324,
 author = {Sulzmann, Martin and Chakravarty, Manuel M. T. and Jones, Simon Peyton and Donnelly, Kevin},
 title = {System F with Type Equality Coercions},
 booktitle = {Proceedings of the 2007 ACM SIGPLAN International Workshop on Types in Languages Design and Implementation},
 series = {TLDI '07},
 year = {2007},
 isbn = {1-59593-393-X},
 location = {Nice, Nice, France},
 pages = {53--66},
 numpages = {14},
 url = {http://doi.acm.org/10.1145/1190315.1190324},
 doi = {10.1145/1190315.1190324},
 acmid = {1190324},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {advanced type features, typed intermediate language},
}

@book{pierce2002types,
  title={Types and Programming Languages},
  author={Pierce, B.C.},
  isbn={9780262162098},
  lccn={2001044428},
  series={Types and Programming Languages},
  url={https://books.google.be/books?id=ti6zoAC9Ph8C},
  year={2002},
  publisher={MIT Press}
}

@article{Bottu:2017:QCC:3156695.3122967,
 author = {Bottu, Gert-Jan and Karachalias, Georgios and Schrijvers, Tom and Oliveira, Bruno C. d. S. and Wadler, Philip},
 title = {Quantified Class Constraints},
 journal = {SIGPLAN Not.},
 issue_date = {October 2017},
 volume = {52},
 number = {10},
 month = sep,
 year = {2017},
 issn = {0362-1340},
 pages = {148--161},
 numpages = {14},
 url = {http://doi.acm.org/10.1145/3156695.3122967},
 doi = {10.1145/3156695.3122967},
 acmid = {3122967},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Haskell, type classes, type inference},
}

@article{outsideinx-modular-type-inference-with-local-assumptions,
author = {Vytiniotis, Dimitrios and Peyton Jones, Simon and Schrijvers, Tom and Sulzmann, Martin},
title = {OutsideIn(X): Modular type inference with local assumptions},
booktitle = {},
year = {2011},
month = {September},
abstract = {

Advanced type system features, such as GADTs, type classes and type families, have proven to be invaluable language extensions for ensuring data invariants and program correctness. Unfortunately, they pose a tough problem for type inference when they are used as local type assumptions. Local type assumptions often result in the lack of principal types and cast the generalisation of local let-bindings prohibitively difficult to implement and specify. User-declared axioms only make this situation worse. In this paper, we explain the problems and-perhaps controversially-argue for abandoning local let-binding generalisation. We give empirical results that local let generalisation is only sporadically used by Haskell programmers. Moving on, we present a novel constraint-based type inference approach for local type assumptions. Our system, called OutsideIn(X), is parameterised over the particular underlying constraint domain X, in the same way as HM(X). This stratification allows us to use a common metatheory and inference algorithm. OutsideIn(X) extends the constraints of X by introducing implication constraints on top. We describe the strategy for solving these implication constraints, which, in turn, relies on a constraint solver for X. We characterise the properties of the constraint solver for X so that the resulting algorithm only accepts programs with principal types, even when the type system specification accepts programs that do not enjoy principal types. Going beyond the general framework, we give a particular constraint solver for X = type classes + GADTs + type families, a non-trivial challenge in its own right. This constraint solver has been implemented and distributed as part of GHC 7.


},
publisher = {Cambridge University Press},
url = {https://www.microsoft.com/en-us/research/publication/outsideinx-modular-type-inference-with-local-assumptions/},
address = {},
pages = {333â€“412},
journal = {Journal of Functional Programming},
volume = {21},
chapter = {},
isbn = {},
}

@unpublished{understanding-functional-dependencies-via-constraint-handling-rules,
author = {Sulzmann, Martin and Duck, Gregory and Peyton Jones, Simon and Stuckey, Peter},
title = {Understanding functional dependencies via constraint handling rules},
booktitle = {},
year = {2006},
month = {January},
abstract = {Functional dependencies are a popular and useful extension to Haskell style type classes. In this paper, we give a reformulation of functional dependencies in terms of Constraint Handling Rules (CHRs). In previous work, CHRs have been employed for describing user-programmable type extensions in the context of Haskell style type classes. Here, we make use of CHRs to provide for the first time a concise result that under some sufficient conditions, functional dependencies allow for sound, complete and decidable type inference. The sufficient conditions imposed on functional dependencies can be very limiting. We show how to safely relax these conditions and suggest several sound extensions of functional dependencies. Our results allow for a better understanding of functional dependencies and open up the opportunity for new applications.},
publisher = {},
url = {https://www.microsoft.com/en-us/research/publication/understanding-functional-dependencies-via-constraint-handling-rules/},
address = {},
pages = {},
journal = {},
volume = {},
chapter = {},
isbn = {},
}

@inproceedings{associated-types-with-class,
author = {Peyton Jones, Simon},
title = {Associated types with class},
booktitle = {POPL '05: Proceedings of the 32nd ACM SIGPLAN-SIGACT sysposium on Principles of programming languages},
year = {2005},
month = {January},
abstract = {

In this paper, we explore an extension to Haskell type classes that allows a type class declaration to define data types as well as values (or methods). Similarly, an instance declaration gives a witness for such data types, as well as a witness for each method. It turns out that this extension directly supports the idea of a type-indexed type, and is useful in many applications, especially for self-optimising libraries that adapt their data representations and algorithms in a type-directed manner.
Crucially, just as Haskell's existing type-class mechanism can be explained by translation into System F, so we can explain our extension by translation into System F, and we do so in full detail. This is a valuable property since it ensures that the addition of associated data types to an existing Haskell compiler leads to changes in the front end only. assoc
In this paper, we explore an extension to Haskell type classes that allows a type class declaration to define data types as well as values (or methods). Similarly, an instance declaration gives a witness for such data types, as well as a witness for each method. It turns out that this extension directly supports the idea of a type-indexed type, and is useful in many applications, especially for self-optimising libraries that adapt their data representations and algorithms in a type-directed manner.

Crucially, just as Haskell's existing type-class mechanism can be explained by translation into System F, so we can explain our extension by translation into System F, and we do so in full detail. This is a valuable property since it ensures that the addition of associated data types to an existing Haskell compiler leads to changes in the front end only.},
publisher = {ACM Press},
url = {https://www.microsoft.com/en-us/research/publication/associated-types-with-class/},
address = {},
pages = {1â€“13},
journal = {},
volume = {},
chapter = {},
isbn = {1-58113-830-X},
}
